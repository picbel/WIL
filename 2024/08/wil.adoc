// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202408]]
== 2024년 08월

[[section-202408-1일]]
1일
===
### SELECT ... FOR UPDATE 와 SKIP LOCKED

데이터베이스에서 여러 트랜잭션이 동시에 같은 데이터를 건드리면 충돌이 생길 수 있다. 
이걸 막기 위해 `SELECT ... FOR UPDATE`와 `SKIP LOCKED` 같은 잠금 기능을 사용한다.

#### SELECT ... FOR UPDATE

`SELECT ... FOR UPDATE`는 특정 데이터를 선택하면서 다른 트랜잭션이 그 데이터를 수정하지 못하게 잠그는 SQL 문이다. 
쉽게 말해, 내가 데이터 하나를 잡아두고 일을 끝낼 때까지 다른 사람이 그 데이터를 못 건드리게 하는 것.
Record Lock을 건다. 트랜잭션에서 lock을 record에 잡는다 생각하면 된다
은행 계좌 같은 걸 예로 들면, 내가 잔액을 수정할 때 다른 사람이 동시에 수정 못 하게 막아주는 기능이다.

#### SKIP LOCKED

`SKIP LOCKED`는 `FOR UPDATE`와 함께 쓰이는 옵션으로, 이미 다른 트랜잭션이 잠근 데이터를 건너뛰고 잠기지 않은 데이터만 선택하게 해준다. 

#### SELECT ... FOR UPDATE SKIP LOCKED 활용법
이 기능은 작업 큐를 만들 때 아주 유용하다. 
여러 작업자가 동시에 큐에서 작업을 가져가야 할 때, 이미 누군가 잡은 작업은 건너뛰고 새로운 작업을 가져올 수 있기 때문이다.

`SELECT ... FOR UPDATE SKIP LOCKED`를 이용해 작업 큐를 쉽게 만들 수 있다. 작업 큐는 여러 프로세스가 동시에 작업을 처리할 때 유용하다. 각 작업자는 큐에서 작업을 가져와 처리하고, 완료되면 큐에서 제거한다.

**작업 선택 및 잠금**: 여러 작업자가 동시에 큐에서 작업을 가져갈 때, 아래 쿼리로 잠기지 않은 작업을 선택할 수 있다.
```sql
SELECT task_id, task_data
FROM task_queue
WHERE status = 'PENDING'
FOR UPDATE SKIP LOCKED
LIMIT 1;
```

**작업 상태 업데이트**: 선택한 작업의 상태를 'IN_PROGRESS'로 업데이트해서 다른 작업자가 같은 작업을 가져가지 않도록 한다.
```sql
UPDATE task_queue
SET status = 'IN_PROGRESS'
WHERE task_id = <선택한 작업의 ID>;
```

**작업 완료 처리**: 작업이 끝나면 상태를 'COMPLETED'로 바꾸거나, 작업 큐에서 아예 삭제한다.

```sql
UPDATE task_queue
SET status = 'COMPLETED'
WHERE task_id = <작업 ID>;
```

or

```sql
DELETE FROM task_queue
WHERE task_id = <작업 ID>;
```

이렇게 하면 여러 작업자가 동시에 작업을 처리할 수 있어 처리 속도가 빨라진다. 특히 대규모 데이터 처리나 분산 시스템에서 유용하다.


[[section-202408-5일]]
5일
===
### 응답지연값
구글의 제프 딘이 2010년에 공개한 통상적인 컴퓨터에서 구현된 연산들의 응답지연값을 공개하였다.
이중 몇몇은 컴퓨터 성능 향상에 따라 더이상 유효하진 않지만 구현전 대략적인 계산을 할 수 있게 해준다.

.응답지연 값
|=== 
|연산명 |시간 

|L1캐쉬 참조 |0.5ns 
|분기 예측 오류(branch misspredict) |5ns
|L2캐쉬 참조 |7ns
|mutex 락/ 언락 |100ns
|주 메모리 참조 |10,000ns
|1Gpbs 네트워크로 2KB 전송 |20,000ns
|메모리에서 1MB 순차적으로 읽기 |250,000ns
|같은 데이터 센터 내에서의 메시지 왕복 지연시간 |500,000ns
|디스크 탐색(seek) |10ms
|네트워크에서 1MB 순차적으로 읽기  |10ms
|디스크에서 1MB 순차적으로 읽기  |30ms
|한 패킷의 CA(캘리포니아)로부터 네덜란드까지의 왕복 지연시간 |150ms
|===

---

[[section-202408-18일]]
18일
===
### Flow, emit (Kotlin Coroutine)

#### Flow
`Flow` 는 연속적인 데이터를 비동기적으로 제공하는데 중점을 둔다. 
예를 들어, 시간이 지남에 따라 데이터를 하나씩 생성하거나, API 호출 결과를 순차적으로 처리할 때 유용하다

#### emit
`emit` 은 `Flow` 내부에서 데이터를 발행하는 데 사용한다.
좀 더 이해하기 쉽게 설명하면 `Flow` 내부의 흐름을 `emit` 함수를 통해 결과를 방출한다.
이렇게 발행(방출)된 결과를 `collect` 를 이용해 데이터를 수집한다

```kotlin
fun simpleFlow(): Flow<Int> = flow {
    for (i in 1..5) {
        emit(i)  // 데이터를 하나씩 발행(emit)합니다.
    }
}

// 실행결과 1,2,3,4,5
suspend fun collectFlow() {
    simpleFlow().collect { value ->
        println(value)
    }
}

```

#### Flow 특징
1. `Flow` 는 `collect` 가 호출되기 전까지 실행되지 않으며, `collect` 를 호출할 때마다 새로 시작된다.
2. 비동기적으로 데이터를 발행할 수 있다.
3. map, filter, reduce와 같은 다양한 연산자를 지원함

---

[[section-202408-22일]]
22일
===
### CPU 파이프라인(Pipeline)

CPU의 파이프라인(Pipeline)은 명령어를 보다 효율적으로 처리하기 위해 명령어 실행을 여러 단계로 나누고, 각 단계에서 동시에 여러 명령어를 처리하는 기술이다. 
비유를 하면 공장의 조립 라인을 생각하면 된다. 공장에서 여러 작업이 동시에 이루어지듯, CPU도 파이프라인을 통해 여러 명령어를 동시에 처리하여 성능 향상시킨다.

#### 파이프라인의 기본 개념
전통적인 CPU는 한 번에 하나의 명령어를 처리하는데 예를 들어, 명령어를 불러오고, 해석하고, 실행하고, 결과를 저장하는 단계를 순차적으로 처리한다. 
하지만 이러한 방식은 비효율적입니다. CPU가 하나의 명령어를 불러오는 동안 다른 명령어는 아무 작업도 하지 못하고 대기해야 하기 때문이다.
파이프라인은 이 문제를 해결하기 위해 명령어 실행을 여러 단계로 나누고, 각 단계에서 동시에 다른 명령어를 처리한다.

일반적인 파이프라인의 단계는 다음과 같다.

- 명령어 가져오기(IF: Instruction Fetch): 메모리에서 명령어를 가져옵니다.
- 명령어 해석(ID: Instruction Decode): 명령어를 해석하고 어떤 작업을 수행할지 결정합니다.
- 실행(EX: Execute): 명령어를 실제로 실행합니다.
- 메모리 접근(MEM: Memory Access): 메모리에서 데이터를 읽거나 씁니다.
- 쓰기(WB: Write Back): 실행 결과를 레지스터에 저장합니다.

이렇게 다섯 단계로 나눠진 파이프라인에서는 각 단계가 동시에 동작하므로, CPU는 매 클럭 사이클마다 새로운 명령어를 처리할 수 있다.

#### 파이프라인의 작동 예시
예를 들어, 3개의 명령어(A,B,C)가 있다고 가정해보면 이 명령어들이 파이프라인에서 처리되는 과정은 다음과 같다

|=== 
|사이클	|IF 단계	|ID 단계	|EX 단계	|MEM 단계 |WB 단계
|1	|A	| | ||			
|2	|B	|A |||		
|3	|C	|B	|A ||
|4	|D	|C	|B	|A	|
|5	|E	|D	|C	|B	|A
|===
이렇게 명령어들이 파이프라인을 따라 이동하면서 동시에 처리된다

#### 파이프라인 장단점
**장점** 
- 성능 향상: 여러 명령어를 동시에 처리하여 CPU의 효율을 극대화한다.
- 고속 처리: 매 클럭 주기마다 새로운 명령어가 완료될 수 있으므로 명령어 처리 속도가 빨라진다.

**단점**
- 분기 예측 오류(Branch Misprediction) : 분기 예측이 잘못되었을 때 발생하는 오류
- 데이터 종속성(Data Hazard) : 이전 명령어의 결과가 다음 명령어에 필요할 때 발생하는 문제로, 파이프라인에서 명령어 실행 순서가 지연되거나 멈추게 되는 현상입니다.

---

[[section-202408-24일]]
24일
===
### 분기 예측(Branch Prediction)이란?

CPU는 프로그램을 실행하면서 조건문을 자주 만나게 된다. ex (if, for, while)
CPU는 조건문을 평가한 후에 다음 실행할 명령어를 결정해야 하는데 조건문을 매번 평가하고 다음 명령어를 선택하면, CPU 파이프라인의 성능이 저하 될 수 있다.
이를 해결하기 위해, CPU는 조건을 평가하기 전에 다음에 실행될 명령어를 미리 예측한다. 
예를 들어, 어떤 조건문이 과거에 "참"으로 평가된 빈도가 높았다면, CPU는 다음에도 "참"일 것이라고 예측하고 그에 맞는 명령어를 미리 처리합니다.
이러한 기술을 **분기 예측(Branch Prediction)**이라고 한다

#### 분기 예측 오류(Branch Mispredict)란?
분기 예측이 잘못되었을 때 발생하는 오류를 분기 예측 오류라고 한다.
예를 들어, CPU가 다음 명령어를 "참"일 것으로 예측하고 처리했지만 실제로는 "거짓"인 경우, 이미 수행한 작업을 모두 취소하고 다시 올바른 경로로 명령어를 처리해야 한다.
이 과정에서 CPU의 파이프라인이 비워지고, 성능이 저하된다.

분기 예측 오류는 CPU가 성능 최적화를 위해 분기 예측을 시도할 때 발생하는 부작용입니다. 이러한 오류가 발생하면 CPU의 파이프라인이 초기화되고 성능 저하가 발생하므로, CPU 설계에서 중요한 고려 요소 중 하나입니다.

---

[[section-202408-27일]]
27일
===
### 다익스트라
