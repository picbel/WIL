// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202408]]
== 2024년 08월

[[section-202408-1일]]
1일
===
### SELECT ... FOR UPDATE 와 SKIP LOCKED

데이터베이스에서 여러 트랜잭션이 동시에 같은 데이터를 건드리면 충돌이 생길 수 있다. 
이걸 막기 위해 `SELECT ... FOR UPDATE`와 `SKIP LOCKED` 같은 잠금 기능을 사용한다.

#### SELECT ... FOR UPDATE

`SELECT ... FOR UPDATE`는 특정 데이터를 선택하면서 다른 트랜잭션이 그 데이터를 수정하지 못하게 잠그는 SQL 문이다. 
쉽게 말해, 내가 데이터 하나를 잡아두고 일을 끝낼 때까지 다른 사람이 그 데이터를 못 건드리게 하는 것.
Record Lock을 건다. 트랜잭션에서 lock을 record에 잡는다 생각하면 된다
은행 계좌 같은 걸 예로 들면, 내가 잔액을 수정할 때 다른 사람이 동시에 수정 못 하게 막아주는 기능이다.

#### SKIP LOCKED

`SKIP LOCKED`는 `FOR UPDATE`와 함께 쓰이는 옵션으로, 이미 다른 트랜잭션이 잠근 데이터를 건너뛰고 잠기지 않은 데이터만 선택하게 해준다. 

#### SELECT ... FOR UPDATE SKIP LOCKED 활용법
이 기능은 작업 큐를 만들 때 아주 유용하다. 
여러 작업자가 동시에 큐에서 작업을 가져가야 할 때, 이미 누군가 잡은 작업은 건너뛰고 새로운 작업을 가져올 수 있기 때문이다.

`SELECT ... FOR UPDATE SKIP LOCKED`를 이용해 작업 큐를 쉽게 만들 수 있다. 작업 큐는 여러 프로세스가 동시에 작업을 처리할 때 유용하다. 각 작업자는 큐에서 작업을 가져와 처리하고, 완료되면 큐에서 제거한다.

**작업 선택 및 잠금**: 여러 작업자가 동시에 큐에서 작업을 가져갈 때, 아래 쿼리로 잠기지 않은 작업을 선택할 수 있다.
```sql
SELECT task_id, task_data
FROM task_queue
WHERE status = 'PENDING'
FOR UPDATE SKIP LOCKED
LIMIT 1;
```

**작업 상태 업데이트**: 선택한 작업의 상태를 'IN_PROGRESS'로 업데이트해서 다른 작업자가 같은 작업을 가져가지 않도록 한다.
```sql
UPDATE task_queue
SET status = 'IN_PROGRESS'
WHERE task_id = <선택한 작업의 ID>;
```

**작업 완료 처리**: 작업이 끝나면 상태를 'COMPLETED'로 바꾸거나, 작업 큐에서 아예 삭제한다.

```sql
UPDATE task_queue
SET status = 'COMPLETED'
WHERE task_id = <작업 ID>;
```

or

```sql
DELETE FROM task_queue
WHERE task_id = <작업 ID>;
```

이렇게 하면 여러 작업자가 동시에 작업을 처리할 수 있어 처리 속도가 빨라진다. 특히 대규모 데이터 처리나 분산 시스템에서 유용하다.


[[section-202408-5일]]
5일
===
### 응답 지연 값

대략적인 응답 지연 값들

---

[[section-202408-18일]]
18일
===
### Flow, emit (Kotlin Coroutine)
코틀린 코루틴 flow emit

비동기 flow

emit은 결과를 방출 



---

[[section-202408-22일]]
22일
===


---

[[section-202408-24일]]
24일
===


