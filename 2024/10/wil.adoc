// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202410]]
== 2024년 10월

[[section-202410-3일]]
3일
===
### 이벤트 소싱 (Event Sourcing)

이벤트 소싱(Event Sourcing)은 일반적인 방식의 데이터 저장 방법과 달리, 데이터의 상태 변화를 발생시키는 **이벤트(Event)**를 저장하고, 이 이벤트들의 연속된 흐름을 재생하여 시스템의 현재 상태를 만들어내는 패턴이다.

#### 이벤트 소싱의 핵심 개념
1. **이벤트 저장**: 데이터의 상태를 직접 저장하지 않고, 상태 변화가 일어날 때마다 그 변화를 설명하는 이벤트를 기록한다.
2. **이벤트 재생**: 필요할 때 저장된 모든 이벤트를 순차적으로 재생하여 데이터의 현재 상태를 복원할 수 있다.
3. **불변성**: 이벤트는 변경할 수 없는 기록으로 남으며, 과거 상태를 언제든지 추적하거나 복원할 수 있다.
4. **장점**:
   - 모든 변경 사항을 기록하므로, 과거 상태로 돌아가거나 리플레이하여 문제를 디버깅할 수 있습니다.
   - 시스템의 상태 변화 내역이 명확하게 남아 있어 데이터 감사(Audit)가 용이합니다.
   - 시스템의 상태를 다양한 시점에서 재생하여 원하는 시점의 상태를 분석하거나, 추가 기능을 개발할 수 있습니다.

#### 이벤트 소싱으로 해결하기 좋은 문제
1. 상태 변경 이력을 유지해야 하는 시스템: 회계 시스템이나 금융 거래 시스템같이 모든 트랜잭션 기록을 남기는 것이 중요한 시스템
2. 복잡한 비즈니스 규칙과 프로세스: 복잡한 비즈니스 로직이 있는 경우, 이벤트 소싱을 사용하면 각 단계별 상태를 추적할 수 있다
3. 이벤트 기반 아키텍처를 사용하고자 하는 경우: 마이크로서비스 아키텍처나 서버리스 환경에서 이벤트를 기반으로 시스템 간의 상호작용을 구축할 때 유용하다. (만약 실패가 나도 보상 트랜잭션으로 마지막 이벤트만 지우면되니)

---

[[section-202410-5일]]
5일
===
### 사가 패턴(Saga Pattern)

사가 패턴(Saga Pattern)은 분산 트랜잭션환경에서 데이터 일관성을 유지하기 위한 패턴이다.

#### 사가 패턴의 핵심 개념
1. **분산 트랜잭션**:
   - 사가 패턴은 분산 트랜잭션에서 실행되는 트랜잭션을 단일 트랜잭션처럼 관리하는 데 사용된다.
   - 한 번의 트랜잭션이 여러 서비스에 걸쳐 있을 때 각 서비스는 **로컬 트랜잭션**을 수행한다.
   - 전통적인 단일 트랜잭션과 달리, 분산 트랜잭션은 데이터베이스의 글로벌 락을 사용할 수 없기 때문에 트랜잭션 관리가 복잡해진다.

2. **단계별 트랜잭션 처리**:
   - 사가 패턴은 여러 단계로 나눠진 트랜잭션으로 구성된다.
   - 각 단계는 로컬 트랜잭션을 수행하고, 그 결과가 성공하면 다음 단계를 진행시킨다. 이 과정이 반복되면서 전체 작업이 완료된다.

3. **보상 트랜잭션**:
   - 만약 어느 단계에서 **실패**가 발생하면, 이미 완료된 트랜잭션을 취소하기 위한 **보상 트랜잭션**이 실행된다.
   - 보상 트랜잭션은 기존 작업을 되돌리는 형태로 실행되며, 전체 시스템의 일관성을 유지한다.
   - 예를 들어, 결제가 실패하면 예약했던 항공권을 취소하거나, 상품 배송을 중단하는 등의 작업이 보상 트랜잭션을 통해 수행된다.

#### 사가 패턴의 종류

1. **코레오그래피(Choreography)**:
   - 사가의 각 단계가 독립적으로 **이벤트 기반**으로 수행되는 방식이다.
   - 한 서비스에서 트랜잭션이 완료되면 이벤트를 발생시키고, 그 이벤트를 다른 서비스가 수신하여 다음 트랜잭션을 실행한다.
   - 각 서비스는 자체적으로 다른 서비스에 의존하지 않고 이벤트를 처리하며, 중앙 집중식 관리자가 없다.
   - 장점: 서비스 간 결합도가 낮고 유연합니다.
   - 단점: 서비스 간 이벤트 흐름이 복잡해질 수 있으며, 전체 흐름을 추적하기 어려울 수 있습니다.

2. **오케스트레이션(Orchestration)**:
   - 중앙에서 **오케스트레이터**가 모든 사가 트랜잭션을 **관리**합니다.
   - 오케스트레이터는 각 서비스에 순차적으로 트랜잭션을 실행하도록 명령하며, 성공/실패 여부에 따라 다음 트랜잭션을 실행하거나 보상 트랜잭션을 실행한다.
   - 장점: 트랜잭션 흐름이 명확하며 관리가 용이합니다.
   - 단점: 오케스트레이터가 단일 실패 지점(Single Point of Failure)이 될 수 있다.

#### 사가 패턴의 장점
- **데이터 일관성**: 여러 서비스에 걸친 트랜잭션에서도 데이터를 일관되게 유지할 수 있다.
- **확장성**: 전통적인 트랜잭션과 달리 글로벌 락을 사용하지 않으므로, 다양한 데이터베이스를 사용 할 수 있다. 또한 마이크로서비스 환경과도 잘 어울린다.
- **비동기성**: 코레오그래피 방식의 경우 비동기적으로 각 서비스가 동작하므로, 시스템 전체가 동기화될 필요가 없다.

#### 사가 패턴의 단점
- **보상 트랜잭션의 설계**: 실패 시의 복구 로직, 즉 보상 트랜잭션을 설계하는 것이 까다로울 수 있다. 모든 트랜잭션에 대해 적절한 보상 트랜잭션을 설계해야 한다.
- **복잡성**: 여러 단계로 이루어진 트랜잭션 흐름을 관리하는 데 복잡성이 증가할 수 있다. 특히 코레오그래피 방식의 경우 이벤트 흐름이 복잡해질 수 있다.
- **오케스트레이터의 부담**: 오케스트레이션 방식의 경우 중앙 관리자가 과부하나 실패에 취약할 수 있다. 단일장애점으로 서비스의 취약한 부분이 될 수도 있다.

---

[[section-202410-11일]]
11일
===
### Consistent Hashing

Consistent Hashing은 분산 시스템에서 데이터를 균등하게 분배하고, 노드의 추가/삭제 시 데이터 이동을 최소화하기 위해 사용되는 해싱 기법이다.  

#### 작동 원리  
데이터와 노드를 해시 링(Hash Ring)에 매핑하여 특정 데이터는 자신보다 가까운 시계 방향 노드에 저장된다.
노드 추가/삭제 시 기존 데이터 중 일부만 재배치되므로 효율적이다.  

#### 장점  
1. **확장성**: 노드 추가/삭제 시 데이터 이동이 최소화
2. **가용성**: 일부 노드 장애 시에도 시스템이 안정적으로 동작 
3. **부하 균등 분배**: 데이터를 고르게 분산

#### 활용 사례  
분산 캐시(Redis, Memcached), 분산 데이터베이스(Cassandra, DynamoDB), 로드 밸런싱, 분산 파일 시스템 등에서 널리 사용된다.

---

[[section-202410-16일]]
16일
===
### 스프링 상태머신 (Spring StateMachine)

스프링에서 상태 기반의 비즈니스 로직을 처리하는 애플리케이션을 보다 쉽게 개발할 수 있도록 도와주는 Spring 프레임워크의 모듈이다.
주요 기능을 간단히 요약하면 다음과 같다.

1. 상태 전이 관리: 객체나 시스템이 여러 상태를 가지는 경우, 상태 간의 전이를 관리할 수 있다. 
예를 들어, 주문 처리 시스템에서 주문이 '대기', '처리 중', '완료' 등의 상태를 갖고, 특정 이벤트에 따라 상태간의 전이를 효율적으로 관리 할 수 있다.
2. 이벤트 기반 트리거: 특정 이벤트(사용자 동작, 외부 입력 등)에 따라 상태가 변할 수 있다. 
Spring StateMachine은 이러한 이벤트를 기반으로 상태 전이를 자동으로 처리해준다.
3. 상태와 이벤트의 분리: 상태와 이벤트를 명확하게 분리하여 관리할 수 있다.
4. 계층형 상태: 상태가 복잡하거나 계층적인 경우, 이를 계층형으로 구성하여 관리할 수 있다. 
예를 들어, '진행 중' 상태 안에 여러 세부 상태('검토 중', '승인 대기', '반려' 등)를 추가할 수 있다.
5. 상태 전이 중 인터셉터 또는 액션: 특정 상태로 전이되기 전에 또는 후에 특정 로직을 수행할 수 있는 액션이나 가드를 설정할 수 있다. 

참고하면 좋은 아티클
https://dev.gmarket.com/52

---

[[section-202410-29일]]
29일
===
### ushr(n), shr(n)

둘다 정수 타입에 사용하는 함수이다

#### ushr
- 부호 비트를 무시한다. 이 특성때문에 항상 양수 취급된다.
- 왼쪽에 항상 0을 채운다.

#### shr
- 부호 비트를 무시하지 않는다.
- 양수의 경우 왼쪽에 0을 채운다, 음수의 경우 왼쪽에 1을 채운다

표로 간단히 요약하면 다음과 같다
|===
| 연산자 | 부호 비트 처리             | 왼쪽 빈 자리     | 문법

| `ushr`
| **부호 비트 무시**
| `0`
| `>>>`

| `shr`
| **부호 비트를 유지**
| 양수: `0`, 음수: `1`
| `>>`
|===



