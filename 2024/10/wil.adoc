// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202410]]
== 2024년 10월

[[section-202410-3일]]
3일
===
### 이벤트 소싱 (Event Sourcing)

이벤트 소싱(Event Sourcing)은 일반적인 방식의 데이터 저장 방법과 달리, 데이터의 상태 변화를 발생시키는 **이벤트(Event)**를 저장하고, 이 이벤트들의 연속된 흐름을 재생하여 시스템의 현재 상태를 만들어내는 패턴이다.

#### 이벤트 소싱의 핵심 개념
1. **이벤트 저장**: 데이터의 상태를 직접 저장하지 않고, 상태 변화가 일어날 때마다 그 변화를 설명하는 이벤트를 기록한다.
2. **이벤트 재생**: 필요할 때 저장된 모든 이벤트를 순차적으로 재생하여 데이터의 현재 상태를 복원할 수 있다.
3. **불변성**: 이벤트는 변경할 수 없는 기록으로 남으며, 과거 상태를 언제든지 추적하거나 복원할 수 있다.
4. **장점**:
   - 모든 변경 사항을 기록하므로, 과거 상태로 돌아가거나 리플레이하여 문제를 디버깅할 수 있습니다.
   - 시스템의 상태 변화 내역이 명확하게 남아 있어 데이터 감사(Audit)가 용이합니다.
   - 시스템의 상태를 다양한 시점에서 재생하여 원하는 시점의 상태를 분석하거나, 추가 기능을 개발할 수 있습니다.

#### 이벤트 소싱으로 해결하기 좋은 문제
1. 상태 변경 이력을 유지해야 하는 시스템: 회계 시스템이나 금융 거래 시스템같이 모든 트랜잭션 기록을 남기는 것이 중요한 시스템
2. 복잡한 비즈니스 규칙과 프로세스: 복잡한 비즈니스 로직이 있는 경우, 이벤트 소싱을 사용하면 각 단계별 상태를 추적할 수 있다
3. 이벤트 기반 아키텍처를 사용하고자 하는 경우: 마이크로서비스 아키텍처나 서버리스 환경에서 이벤트를 기반으로 시스템 간의 상호작용을 구축할 때 유용하다. (만약 실패가 나도 보상 트랜잭션으로 마지막 이벤트만 지우면되니)

---

[[section-202410-5일]]
5일
===
### 사가 패턴(Saga Pattern)

사가 패턴(Saga Pattern)은 분산 트랜잭션환경에서 데이터 일관성을 유지하기 위한 패턴이다.

#### 사가 패턴의 핵심 개념
1. **분산 트랜잭션**:
   - 사가 패턴은 분산 트랜잭션에서 실행되는 트랜잭션을 단일 트랜잭션처럼 관리하는 데 사용된다.
   - 한 번의 트랜잭션이 여러 서비스에 걸쳐 있을 때 각 서비스는 **로컬 트랜잭션**을 수행한다.
   - 전통적인 단일 트랜잭션과 달리, 분산 트랜잭션은 데이터베이스의 글로벌 락을 사용할 수 없기 때문에 트랜잭션 관리가 복잡해진다.

2. **단계별 트랜잭션 처리**:
   - 사가 패턴은 여러 단계로 나눠진 트랜잭션으로 구성된다.
   - 각 단계는 로컬 트랜잭션을 수행하고, 그 결과가 성공하면 다음 단계를 진행시킨다. 이 과정이 반복되면서 전체 작업이 완료된다.

3. **보상 트랜잭션**:
   - 만약 어느 단계에서 **실패**가 발생하면, 이미 완료된 트랜잭션을 취소하기 위한 **보상 트랜잭션**이 실행된다.
   - 보상 트랜잭션은 기존 작업을 되돌리는 형태로 실행되며, 전체 시스템의 일관성을 유지한다.
   - 예를 들어, 결제가 실패하면 예약했던 항공권을 취소하거나, 상품 배송을 중단하는 등의 작업이 보상 트랜잭션을 통해 수행된다.

#### 사가 패턴의 종류

1. **코레오그래피(Choreography)**:
   - 사가의 각 단계가 독립적으로 **이벤트 기반**으로 수행되는 방식이다.
   - 한 서비스에서 트랜잭션이 완료되면 이벤트를 발생시키고, 그 이벤트를 다른 서비스가 수신하여 다음 트랜잭션을 실행한다.
   - 각 서비스는 자체적으로 다른 서비스에 의존하지 않고 이벤트를 처리하며, 중앙 집중식 관리자가 없다.
   - 장점: 서비스 간 결합도가 낮고 유연합니다.
   - 단점: 서비스 간 이벤트 흐름이 복잡해질 수 있으며, 전체 흐름을 추적하기 어려울 수 있습니다.

2. **오케스트레이션(Orchestration)**:
   - 중앙에서 **오케스트레이터**가 모든 사가 트랜잭션을 **관리**합니다.
   - 오케스트레이터는 각 서비스에 순차적으로 트랜잭션을 실행하도록 명령하며, 성공/실패 여부에 따라 다음 트랜잭션을 실행하거나 보상 트랜잭션을 실행한다.
   - 장점: 트랜잭션 흐름이 명확하며 관리가 용이합니다.
   - 단점: 오케스트레이터가 단일 실패 지점(Single Point of Failure)이 될 수 있다.

#### 사가 패턴의 장점
- **데이터 일관성**: 여러 서비스에 걸친 트랜잭션에서도 데이터를 일관되게 유지할 수 있다.
- **확장성**: 전통적인 트랜잭션과 달리 글로벌 락을 사용하지 않으므로, 다양한 데이터베이스를 사용 할 수 있다. 또한 마이크로서비스 환경과도 잘 어울린다.
- **비동기성**: 코레오그래피 방식의 경우 비동기적으로 각 서비스가 동작하므로, 시스템 전체가 동기화될 필요가 없다.

#### 사가 패턴의 단점
- **보상 트랜잭션의 설계**: 실패 시의 복구 로직, 즉 보상 트랜잭션을 설계하는 것이 까다로울 수 있다. 모든 트랜잭션에 대해 적절한 보상 트랜잭션을 설계해야 한다.
- **복잡성**: 여러 단계로 이루어진 트랜잭션 흐름을 관리하는 데 복잡성이 증가할 수 있다. 특히 코레오그래피 방식의 경우 이벤트 흐름이 복잡해질 수 있다.
- **오케스트레이터의 부담**: 오케스트레이션 방식의 경우 중앙 관리자가 과부하나 실패에 취약할 수 있다. 단일장애점으로 서비스의 취약한 부분이 될 수도 있다.

---

[[section-202410-11일]]
11일
===
### Consistent Hashing


---

[[section-202410-16일]]
16일
===
### 스프링상태머신

---
[[section-202410-29일]]
29일
===
###








