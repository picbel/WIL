// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:

[[section-202402]]
== 2024년 02월

[[section-202402-2일]]
2일
===
#### 코틀린 코루틴의 withContext

withContext는 현재 실행 중인 코루틴의 컨텍스트(코루틴이 실행되는 환경)를 변경하는 데 사용되는 중요한 함수이다.
해당 함수의 기능은 I/O 작업이나 CPU 집약적인 계산을 다른 스레드나 디스패처로 전환할 수 있습니다.
withContext는 순차적인 작업 처리에 유용하며, launch나 async와 달리 병렬 실행을 위한 목적으로 사용되지는 않습니다.
이는 withContext가 주로 특정 작업을 다른 컨텍스트로 전환하고 그 결과를 즉시 반환하는 데 초점을 맞추고 있기 때문입니다.

매번 정의가 햇갈려서 한번 정리함

---
[[section-202402-8일]]
8일
===
코틀린 코루틴과 가상쓰레드 내용
https://www.youtube.com/watch?v=szl3eWA0VRw 요약 
현재 작성중

---

[[section-202402-12일]]
12일
===
#### Cache Stampede (캐시 스탬피드)
캐시 스탬피드는 특정 시간에 캐시가 전체적으로 만료되거나 초기화되어 DB나 저장소 혹은 API등에 과도한 요청이 집중되는 현상을 의미합니다.  +
예시로 1000건의 데이터를 5분 만료로 동시에 캐싱하였다하면 5분뒤에 해당 데이터를 전부 조회한다면 모든 데이터에 대해 캐시미스가 발생하게됩니다.

캐시 스탬피드를 방지하기위해서는 여러가지 전략이 있는데  +
1. 캐시 만료 시간 무작위 : 캐싱을 할때 만료시간을 일정하게 하지말고 기준으로부터 약간의 변동을 주어 캐시가 동시에 만료되지 않게 합니다.  +
2. 캐시 갱신 : 백그라운드에서 캐시된 데이터를 주기적으로 갱신하거나 만료되기전에 자동으로 갱신 합니다.  +
3. Lock 메커니즘 : 캐시가 재생성 될 때 해당 데이터에 접근하는 다른 요청들을 대기 시킨후 캐시가 갱신된 이후에 요청을 진행시킵니다.

---

[[section-202402-20일]]
20일
===
#### Spring의 Error처리와 Servlet의 Error 처리
스프링에서 흔히 @ErrorController를 이용해서 에러처리를 하는데 내부 구현이 정확히 어떻게 되어있는지 몰랏는데 이번 기회를 통해알게되었다. +
흔히 외부로 부터 요청이 들어오게되면 다음과 같은 순서를 타고 App의 Controller를 호출한다. 
```
WAS -> filter -> servlet -> interceptor -> Controller
```
이제 요청에서 에러가 발생하여 response.sendError()를 호출하면 WAS에게 까지 내용이 전파된다 +
(response.sendError() 호출안하면 그대로 client에게 was의 에러처리가 응답으로 보내진다) +
WAS는 오류 처리에 대한 정보를 찾아야하기 때문에 다시 요청을 보낸다 +
순서를 그리자면 다음과 같다 +
```
1. 처음 요청시
WAS -> filter -> servlet -> interceptor -> Controller
2. error 발생
WAS(error 전파 완) <- filter <- servlet <- interceptor <- Controller(response.sendError() 호출)
3. 에러 정보를 찾기위해 다시 요청
WAS("/error") -> filter -> servlet -> interceptor -> Controller("/error" 에 맞는 에러 api 호출)
```
이때 다시 요청을 보낼때 filter를 다시 거치게되는데 유저의 요청인지 에러 정보를 찾기위한 요청인지를 구분하기 위해 사용하는것이 `DispatcherType`이라는걸 추가로 사용한다. (servlet에서 제공하는 개념) +
REQUEST : 클라이언트 요청 +
ERROR : 오류 요청 +
이라 보면 된다 +
interceptor는 path를 제외하는 식으로 해결 가능하다

---

[[section-202402-26일]]
26일
===
#### PCB (Process Control Block)
PCB란 Process Control Block의 약자로, os가 프로세스의 실행을 제어하고 관리하기 위해 사용하는 핵심적인 데이터 구조이다. + 
PCB는 프로세스의 생명주기 동안 유지되며, 프로세스가 종료되면 os에 의해 해제됩니다. PCB는 os의 프로세스 관리 기능을 가능하게 하는 핵심 요소입니다.

##### **PCB 에서 저장되는 주요 정보** 
1. **프로세스 식별자(Process ID, PID)**: 각 프로세스를 고유하게 식별하는 번호입니다. + 
2. **프로세스 상태(Process State)**: 준비(Ready), 실행(Running), 대기(Waiting) 등 프로세스의 현재 상태를 나타냅니다. + 
3. **프로그램 카운터(Program Counter, PC)**: 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다. + 
4. **CPU 레지스터**: 프로세스 실행 중에 사용되는 레지스터의 현재 값을 저장합니다. 이는 프로세스의 컨텍스트 스위치(Context Switch) 시에 중요한 역할을 합니다. + 
5. **CPU 스케줄링 정보**: 프로세스 우선순위, 스케줄링 큐에 대한 포인터 등 스케줄링에 필요한 정보가 포함됩니다. + 
6. **메모리 관리 정보**: 프로세스의 주소 공간, 페이지 테이블 등 메모리 관련 정보를 담고 있습니다. + 
7. **입출력 상태 정보**: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등 입출력에 관련된 정보를 포함합니다. + 

##### **PCB의 역할** 
- **프로세스 관리 및 스케줄링**: PCB는 os가 프로세스를 효율적으로 스케줄링하고 관리하는 데 필수적인 정보를 제공합니다. + 
- **컨텍스트 스위칭**: os가 현재 실행 중인 프로세스에서 다른 프로세스로 제어를 전환할 때, PCB에 저장된 정보를 사용하여 프로세스의 상태를 저장하고 복원합니다. 이를 통해 프로세스 간의 전환이 원활하게 이루어집니다. 
