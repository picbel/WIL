// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:

[[section-202402]]
== 2024년 02월

[[section-202402-2일]]
2일
===
### 코틀린 코루틴의 withContext

withContext는 현재 실행 중인 코루틴의 컨텍스트(코루틴이 실행되는 환경)를 변경하는 데 사용되는 중요한 함수이다.
해당 함수의 기능은 I/O 작업이나 CPU 집약적인 계산을 다른 스레드나 디스패처로 전환할 수 있습니다.
withContext는 순차적인 작업 처리에 유용하며, launch나 async와 달리 병렬 실행을 위한 목적으로 사용되지는 않습니다.
이는 withContext가 주로 특정 작업을 다른 컨텍스트로 전환하고 그 결과를 즉시 반환하는 데 초점을 맞추고 있기 때문입니다.

// 주석 테스트
매번 정의가 햇갈려서 한번 정리함

---
[[section-202402-8일]]
8일
===
### 컨텍스트 스위칭

컨텍스트 스위칭은 운영 체제가 현재 실행 중인 프로세스 또는 스레드를 일시 중단하고 다른 프로세스 또는 스레드를 실행하기 위해 상태 정보를 저장하고 복원하는 과정입니다.
이 과정을 통해 멀티태스킹이 가능해집니다

#### 프로세스의 컨텍스트 스위칭
프로세스 컨텍스트 스위칭은 프로세스 제어 블록(PCB)에 저장된 정보, 즉 CPU 레지스터 상태, 프로그램 카운터, 메모리 매핑 정보 등을 포함합니다. 
이 정보는 현재 프로세스의 상태를 나타내며, 다른 프로세스로 전환할 때 이를 보호하고 복원하는 데 사용됩니다.

#### 쓰레드 컨텍스트 스위칭
쓰레드 컨텍스트 스위칭은 프로세스 내에서 발생하며, 쓰레드들이 코드, 데이터, 힙 영역을 공유하기 때문에 비용이 더 낮습니다. 
주로 변경되는 것은 스택과 CPU의 레지스터입니다. 이로 인해 쓰레드 스위칭이 프로세스 스위칭보다 상대적으로 경량입니다.

또한, 컨텍스트 스위칭의 오버헤드는 시스템 성능에 큰 영향을 미칠 수 있습니다. 예를 들어, 고부하 시나리오에서 운영 체제는 효율적인 스케줄링 알고리즘을 사용하여 빈번한 컨텍스트 스위칭을 피하고 캐싱 메커니즘을 통해 자주 사용되는 프로세스의 정보를 빠르게 액세스할 수 있도록 관리합니다. 이러한 최적화는 멀티태스킹 환경에서 반응성과 자원의 효율적인 사용을 보장합니다.

---

[[section-202402-12일]]
12일
===
### Cache Stampede (캐시 스탬피드)
캐시 스탬피드는 특정 시간에 캐시가 전체적으로 만료되거나 초기화되어 DB나 저장소 혹은 API등에 과도한 요청이 집중되는 현상을 의미합니다. 
예시로 1000건의 데이터를 5분 만료로 동시에 캐싱하였다하면 5분뒤에 해당 데이터를 전부 조회한다면 모든 데이터에 대해 캐시미스가 발생하게됩니다.

캐시 스탬피드를 방지하기위해서는 여러가지 전략이 있는데 
1. 캐시 만료 시간 무작위 : 캐싱을 할때 만료시간을 일정하게 하지말고 기준으로부터 약간의 변동을 주어 캐시가 동시에 만료되지 않게 합니다. 
2. 캐시 갱신 : 백그라운드에서 캐시된 데이터를 주기적으로 갱신하거나 만료되기전에 자동으로 갱신 합니다. 
3. Lock 메커니즘 : 캐시가 재생성 될 때 해당 데이터에 접근하는 다른 요청들을 대기 시킨후 캐시가 갱신된 이후에 요청을 진행시킵니다.

---

[[section-202402-20일]]
20일
===
### Spring의 Error처리와 Servlet의 Error 처리
스프링에서 흔히 @ErrorController를 이용해서 에러처리를 하는데 내부 구현이 정확히 어떻게 되어있는지 몰랏는데 이번 기회를 통해알게되었다. 
흔히 외부로 부터 요청이 들어오게되면 다음과 같은 순서를 타고 App의 Controller를 호출한다. 
```
WAS -> filter -> servlet -> interceptor -> Controller
```
이제 요청에서 에러가 발생하여 response.sendError()를 호출하면 WAS에게 까지 내용이 전파된다 
(response.sendError() 호출안하면 그대로 client에게 was의 에러처리가 응답으로 보내진다) 
WAS는 오류 처리에 대한 정보를 찾아야하기 때문에 다시 요청을 보낸다 
순서를 그리자면 다음과 같다 
```
1. 처음 요청시
WAS -> filter -> servlet -> interceptor -> Controller
2. error 발생
WAS(error 전파 완) <- filter <- servlet <- interceptor <- Controller(response.sendError() 호출)
3. 에러 정보를 찾기위해 다시 요청
WAS("/error") -> filter -> servlet -> interceptor -> Controller("/error" 에 맞는 에러 api 호출)
```
이때 다시 요청을 보낼때 filter를 다시 거치게되는데 유저의 요청인지 에러 정보를 찾기위한 요청인지를 구분하기 위해 사용하는것이 `DispatcherType`이라는걸 추가로 사용한다. (servlet에서 제공하는 개념) 
REQUEST : 클라이언트 요청 
ERROR : 오류 요청 
이라 보면 된다 
interceptor는 path를 제외하는 식으로 해결 가능하다

---

[[section-202402-26일]]
26일
===
### PCB (Process Control Block)
PCB란 Process Control Block의 약자로, os가 프로세스의 실행을 제어하고 관리하기 위해 사용하는 핵심적인 데이터 구조이다.  
PCB는 프로세스의 생명주기 동안 유지되며, 프로세스가 종료되면 os에 의해 해제됩니다. PCB는 os의 프로세스 관리 기능을 가능하게 하는 핵심 요소입니다.

#### **PCB 에서 저장되는 주요 정보** 
1. **프로세스 식별자(Process ID, PID)**: 각 프로세스를 고유하게 식별하는 번호입니다.  
2. **프로세스 상태(Process State)**: 준비(Ready), 실행(Running), 대기(Waiting) 등 프로세스의 현재 상태를 나타냅니다.  
3. **프로그램 카운터(Program Counter, PC)**: 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.  
4. **CPU 레지스터**: 프로세스 실행 중에 사용되는 레지스터의 현재 값을 저장합니다. 이는 프로세스의 컨텍스트 스위치(Context Switch) 시에 중요한 역할을 합니다.  
5. **CPU 스케줄링 정보**: 프로세스 우선순위, 스케줄링 큐에 대한 포인터 등 스케줄링에 필요한 정보가 포함됩니다.  
6. **메모리 관리 정보**: 프로세스의 주소 공간, 페이지 테이블 등 메모리 관련 정보를 담고 있습니다.  
7. **입출력 상태 정보**: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등 입출력에 관련된 정보를 포함합니다.  

#### **PCB의 역할** 
- **프로세스 관리 및 스케줄링**: PCB는 os가 프로세스를 효율적으로 스케줄링하고 관리하는 데 필수적인 정보를 제공합니다.  
- **컨텍스트 스위칭**: os가 현재 실행 중인 프로세스에서 다른 프로세스로 제어를 전환할 때, PCB에 저장된 정보를 사용하여 프로세스의 상태를 저장하고 복원합니다. 이를 통해 프로세스 간의 전환이 원활하게 이루어집니다. 
