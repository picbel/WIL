// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202412]]
== 2024년 12월

[[section-202412-2일]]
2일
===
### TransactionManager 와 Kotlin Coroutine

org.springframework:spring-tx 의 org.springframework.transaction.annotation.Transactinal 의 주석내용
```
* <h3>Transaction Management</h3>
*
* <p>This annotation commonly works with thread-bound transactions managed by a
* {@link org.springframework.transaction.PlatformTransactionManager}, exposing a
* transaction to all data access operations within the current execution thread.
* <b>Note: This does NOT propagate to newly started threads within the method.</b>
*
* <p>Alternatively, this annotation may demarcate a reactive transaction managed
* by a {@link org.springframework.transaction.ReactiveTransactionManager} which
* uses the Reactor context instead of thread-local variables. As a consequence,
* all participating data access operations need to execute within the same
* Reactor context in the same reactive pipeline.
```
위 주석내용을 간단히 요약하면 다음과 같다.

#### PlatformTransactionManager
Thread Local


#### ReactiveTransactionManager
Reactor Context



Spring Data에서 reactor와 코틀린 코루틴을 활용하여 CoroutineCrudRepository를 지원하기도 한다
data에 crud행위를 추상화한 인터페이스인 CrudRepository처럼 코루틴으로 data에 crud행위를 추상화한 인터페이스이다.


https://docs.spring.io/spring-data/relational/reference/kotlin/coroutines.html


---

[[section-202412-4일]]
4일
===
### ALPN
https://datatracker.ietf.org/doc/html/rfc7301
Http 프로토콜을 정하기위한 협상 과정

---

[[section-202412-9일]]
9일
===
### 벌크헤드 패턴

---
[[section-202412-12일]]
12일
===
### 서킷브레이커

---
[[section-202412-18일]]
18일
===
### Java 쓰레드 풀의 active count
헷갈려서 쓴다..
활성화된 active count 구하는법 알자

---
[[section-202412-19일]]
19일
===
### 코틀린 코루틴 디스패처

1. **`Dispatchers.Default`**
   - CPU 집약적인 작업에 적합.
   - 공유된 스레드 풀에서 실행.

2. **`Dispatchers.IO`**
   - I/O 작업(네트워크, 파일)에 최적화.
   - 많은 스레드를 사용하는 풀에서 실행.

3. **`Dispatchers.Main`**
   - 메인 스레드에서 실행.
   - 만약 해당 디스페처에서 블로킹 작업을 실행할시 메인 스레드가 블로킹 됨

4. **`Dispatchers.Unconfined`**
   - 특정 스레드에 바인딩되지 않음.
   - 테스트나 간단한 작업에 사용.

5. **커스텀 디스패처**
   - `Executors` 등을 이용해 직접 생성.
   - 특정 요구사항에 맞는 실행 환경 구성.

**사용 예시**: 
- CPU 작업 → `Default`
- I/O 작업 → `IO`
`withContext`로 디스패처 변경 가능.

---
[[section-202412-22일]]
22일
===
### Redis가 빠른 이유
https://iorilan.medium.com/it-is-fast-may-not-be-a-good-answer-to-discuss-redis-during-an-interview-and-here-is-a-better-one-5bb3bc3cd37f

https://velog.io/@redjen/%EB%A0%88%EB%94%94%EC%8A%A4%EB%8A%94-%EC%99%9C-%EB%B9%A0%EB%A5%BC%EA%B9%8C
정리하기

대략 2가지 이유 정리 
1. i/o 멀티플렉싱
2. 싱글쓰레드 기반이라 컨텍스트 스위칭등에서 자유롭다 동시성처리 X
하지만 i/o작업에 한해서 멀티쓰레딩도 적용되었다 (redis 6.0)
적용되는 부분은 다음과 같다
- 클라이언트가 전송한 명령을 네트웍으로 읽어서 파싱하는 부분
- 명령이 처리된 결과 메시지를 클라이언트에게 네트웍으로 전달하는 부분
https://charsyam.wordpress.com/2020/05/05/%EC%9E%85-%EA%B0%9C%EB%B0%9C-redis-6-0-threadedio%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

3. 인메모리 기반 DB이다.

---
[[section-202412-23일]]
23일
===
### epoll 내부 동작 방식

1. epoll 객체 생성:
**Red-Black Tree** (RB-Tree): 등록된 파일 디스크립터(FD)를 관리하는 데 사용됩니다. 이 구조는 FD를 효율적으로 추가, 삭제, 검색할 수 있도록 설계되었습니다.
**Ready List**: RB-Tree에 등록된 FD 중에서 이벤트가 발생한 FD를 별도로 관리하는 리스트입니다. 이 구조는 이벤트 발생 시 epoll_wait가 빠르게 반환될 수 있도록 돕습니다.
추가적으로, Ready List는 링크드 리스트로 구현되며, 이미 Ready List에 추가된 FD는 중복해서 추가되지 않는 특징이 있습니다.

2. epoll에 FD 등록:
epoll_ctl은 FD를 추가(ADD), 수정(MOD), 삭제(DEL)하는 데 사용됩니다.
FD를 등록하면 RB-Tree에 추가됩니다. 등록 시, FD에 감시할 이벤트 타입(예: 읽기 가능, 쓰기 가능, 에러 발생 등)을 지정합니다.
이 단계에서는 Ready List는 여전히 비어 있습니다. 이벤트가 발생하기 전까지 FD는 Ready List로 이동하지 않습니다.

3. 유저 애플리케이션은 Ready List를 감시:
epoll_wait를 호출하면 Ready List에 이벤트가 발생한 FD가 있는지 확인합니다.
Ready List에 항목이 없으면 애플리케이션은 지정된 타임아웃 시간 동안 블록되거나, 타임아웃이 없을 경우 계속 대기(sleep) 상태에 있습니다.
Ready List에 이벤트가 발생한 FD가 있으면, 해당 FD가 반환됩니다.

4. 이벤트 발생(네트워크 예시): 
네트워크 카드 드라이버에서 데이터 수신하면, NIC(Network Interface Card)가 데이터를 메모리로 DMA(Direct Memory Access)를 통해 전달합니다.
이후 커널의 네트워크 스택이 데이터를 처리하며, FD의 소켓 버퍼에 데이터를 저장하고 해당 FD가 Ready List로 이동됩니다.

5. FD를 Ready List로 이동:
소켓 버퍼에 데이터가 기록되거나 FD에 지정된 이벤트 조건(예: 쓰기 가능)이 만족되면 커널은 FD를 Ready List로 이동시킵니다.
Ready List는 FD와 이벤트 정보를 포함하며, epoll_wait가 호출될 때 반환될 준비 상태가 됩니다.

6. 유저 애플리케이션이 Ready List 확인:
epoll_wait가 Ready List의 FD를 반환하면, 애플리케이션은 FD를 사용해 데이터를 읽거나 처리합니다.
FD가 이벤트 처리를 완료한 후에도 조건이 계속 만족되면, FD는 다시 Ready List에 남아 있을 수 있습니다. 이 경우, 중복 처리를 방지하기 위해 애플리케이션에서 추가 처리가 필요할 수 있습니다.

#### epoll의 2가지 모드

* Edge-Triggered (ET)
상태 변화(예: 데이터 도착)가 발생한 순간 한 번만 Ready List에 FD가 추가됩니다.
** 특징: 이벤트가 발생한 후 추가 상태 변화가 없으면, Ready List에 다시 추가되지 않습니다.
데이터가 남아 있더라도 FD는 다시 반환되지 않으므로, 데이터를 모두 읽거나 써야 합니다.
** 적합한 사용 사례:
고성능 요구 환경. 사용자 애플리케이션이 즉각적으로 처리하고 반복적으로 확인하지 않아도 되는 경우.

* Level-Triggered (LT) 모드
FD가 "읽기 가능" 또는 "쓰기 가능" 상태로 유지되는 동안, Ready List에 계속 FD가 추가됩니다.
** 특징:
데이터를 완전히 처리하지 않으면, 다음 epoll_wait 호출 시 같은 FD가 반복적으로 반환됩니다.
모든 데이터를 철저히 읽거나 써야 불필요한 중복 반환이 방지됩니다.
** 적합한 사용 사례:
단순하고 신뢰성 있는 처리를 원하는 경우. 애플리케이션이 데이터를 한 번에 처리하지 못할 수도 있는 경우.

TMI : 레디스는 Edge-Triggered 모드를 사용한다.

---
