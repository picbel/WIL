// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202406]]
== 2024년 06월


[[section-202406-3일]]
3일
===
### 팬텀리드, 반복가능하지않는 조회, 더티리드

팬텀리드, 반복가능하지않는 조회, 더티리드는 트랜잭션내에 격리수준에 따라 일어나는 현상을 말한다.

- 팬텀 리드: 트랜잭션 내에서 동일한 쿼리로 읽었을 때 결과의 개수가 달라지는 것.
- 반복 불가능한 조회: 트랜잭션 내에서 동일한 쿼리로 조회할 때 레코드의 값이 달라지는 것.
- 더티 리드: 다른 트랜잭션에서 커밋되지 않은 상태의 데이터를 조회하는 것.

---
[[section-202406-8일]]
8일
===
### 바운더리 컨텍스트(Bounded Context)

바운더리 컨텍스트는 소프트웨어 시스템 내의 특정한 모델을 정의하는 경계를 의미한다. 
이 경계 내에서 용어와 규칙은 일관되게 유지되며, 외부와의 통신은 명확히 정의된 인터페이스를 통해 이루어집니다.

---

[[section-202406-12일]]
12일
===
### JtaTransactionManager 란?

xa 트랜잭션
주의점
Xa 트랜잭션 미지원으로 인해 레디스 트랜잭션은 jta 트랜잭션을 태울수없다

#### 번외 : ChainedTransactionManager 란?

ChainedTransactionManager가 deprecate 된 이유 : 
https://github.com/spring-projects/spring-data-commons/issues/2232

ChainedTransactionManager is the primary class in org.springframework.data.transaction that is used for multi-transactionmanager arrangements. It is useful to coordinate transactions across multiple resources especially when one transaction manager is a Spring one and the other is a foreign one.

Over time, we found that we're basically emulating distributed transactions on a best-effort basis with known gaps. These gaps lead to inconsistencies or unexpected behavior during rollbacks. Part of the problem is that resource/synchronization storage is a singleton ThreadLocal. Using two transaction managers based on AbstractPlatformTransactionManager causes the first transaction manager to handle all synchronizations regardless of their resource origin (primary and secondary transactional resources). If the second transaction manager commit fails, then already all synchronizations are processed and there's no way to recover.

Therefore, we're going to deprecate ChainedTransactionManager and the entire org.springframework.data.transaction that hosts support classes for multi-transactions

---

[[section-202406-17일]]
17일
===
### Java의 LinkedHashMap과 LRU

LRU캐쉬를 Java에서 구현할때 LinkedHashMap를 이용해서 많이 구현한다.
이때 주의할점이 accessOrder 값을 꼭 true로 지정하여야한다
map의 반복순서를 정하는 값인데
true일 경우 액세스 순서, false일 경우 삽입 순서에 따라 map의 반복순서를 관리합니다.

---

[[section-202406-18일]]
18일
===
### PreparedStatement 동작 방식

PreparedStatement의 set 메서드를 사용하여 파라미터를 바인딩할 때, 실제로는 SQL 문 자체에서 ? 플레이스홀더를 값으로 즉시 변경하는 것이 아니라, 
그 값을 내부적으로 유지하고 있다가 SQL 문을 실행할 때 데이터베이스와 통신하기 위해 바인딩합니다.

---

[[section-202406-23일]]
23일
===
### 외부 호출을 트랜잭션과 묶을 때 주의점
네트워크 에러 가능성
외부서버 응답 시간 느릴때 문제점
트랜잭션 원자성 보장을 위해 실패시 호출 함수 (롤백함수 or 역함수)

---

[[section-202406-26일]]
26일
===

---

[[section-202406-27일]]
27일
===
explain 값들 보는법


