// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


---
https://github.com/picbel/WIL/blob/main/2024/05/wil.adoc[이전 달]
https://github.com/picbel/WIL/blob/main/2024/07/wil.adoc[다음 달]

[[section-202406]]
== 2024년 06월


[[section-202406-3일]]
3일
===
### 팬텀리드, 반복가능하지않는 조회, 더티리드

팬텀리드, 반복가능하지않는 조회, 더티리드는 트랜잭션내에 격리수준에 따라 일어나는 현상을 말한다.

- 팬텀 리드: 트랜잭션 내에서 동일한 쿼리로 읽었을 때 결과의 개수가 달라지는 것.
- 반복 불가능한 조회: 트랜잭션 내에서 동일한 쿼리로 조회할 때 레코드의 값이 달라지는 것.
- 더티 리드: 다른 트랜잭션에서 커밋되지 않은 상태의 데이터를 조회하는 것.

---
[[section-202406-8일]]
8일
===
### 바운더리 컨텍스트(Bounded Context)

바운더리 컨텍스트는 소프트웨어 시스템 내의 특정한 모델을 정의하는 경계를 의미한다. 
이 경계 내에서 용어와 규칙은 일관되게 유지되며, 외부와의 통신은 명확히 정의된 인터페이스를 통해 이루어집니다.

---

[[section-202406-12일]]
12일
===
### JtaTransactionManager 란?

JtaTransactionManager는 Java Transaction API(JTA)를 사용하여 트랜잭션을 관리하는 스프링 프레임워크의 클래스이다. 
이 클래스는 주로 분산 트랜잭션 관리에 사용되며, 여러 데이터 소스와의 작업을 하나의 트랜잭션으로 묶어 관리할 수 있도록 합니다. 
그러나 JTA의 트랜잭션 관리를 위해서는 XA 트랜잭션을 지원하는 데이터 소스가 필요합니다.
예를 들어 Redis는 XA 트랜잭션을 지원하지 않기 때문에, JtaTransactionManager를 사용하여 Redis에서 직접 트랜잭션을 관리할 수 없습니다.

#### XA Transaction
XA 트랜잭션은 분산 트랜잭션 표준 중 하나로, 여러 자원 관리자가 참여하는 트랜잭션을 조율할 때 사용된다.
XA는 두 가지 주요 단계를 통해 분산 트랜잭션을 관리합니다: 준비(Prepare)와 커밋(Commit)/롤백(Rollback).
RDB의 트랜잭션은 왠만하면 XA Transaction를 구현한다.

#### 번외 : ChainedTransactionManager 란?

ChainedTransactionManager가 deprecate 된 이유 : 
ChainedTransactionManager는 org.springframework.data.transaction 패키지의 주요 클래스이며, 다중 트랜잭션 매니저를 조율하는 데 사용됩니다. 특히 하나는 Spring 트랜잭션 매니저이고 다른 하나는 외부(외래) 트랜잭션 매니저일 때, 여러 리소스 간의 트랜잭션을 조정하는 데 유용합니다.

하지만 시간이 지나면서, 이 방식은 기본적으로 결함이 명확한 상태에서의 분산 트랜잭션을 흉내내는 수준이라는 점이 드러났습니다. 이러한 결함들은 롤백 과정에서 일관성 문제나 예기치 못한 동작을 일으킬 수 있습니다. 문제의 일부는 리소스/동기화 정보가 singleton ThreadLocal에 저장된다는 점입니다.
AbstractPlatformTransactionManager 기반의 두 트랜잭션 매니저를 사용할 경우, 모든 동기화 작업은 첫 번째 트랜잭션 매니저에 의해 처리되며, 이때 동기화의 실제 리소스가 무엇인지 구분하지 않습니다 (즉, 1차/2차 트랜잭션 리소스를 구분하지 않음).
만약 두 번째 트랜잭션 매니저의 커밋이 실패하면, 이미 모든 동기화 작업이 끝난 상태이므로 복구할 방법이 없습니다.

따라서 우리는 ChainedTransactionManager와 다중 트랜잭션을 지원하는 보조 클래스들이 포함된 org.springframework.data.transaction 전체를 deprecated 처리할 예정입니다.

원문 링크 : https://github.com/spring-projects/spring-data-commons/issues/2232

---

[[section-202406-17일]]
17일
===
### Java의 LinkedHashMap과 LRU

LRU캐쉬를 Java에서 구현할때 LinkedHashMap를 이용해서 많이 구현한다.
이때 주의할점이 accessOrder 값을 꼭 true로 지정하여야한다
map의 반복순서를 정하는 값인데
true일 경우 액세스 순서, false일 경우 삽입 순서에 따라 map의 반복순서를 관리합니다.

---

[[section-202406-18일]]
18일
===
### PreparedStatement 동작 방식

PreparedStatement의 set 메서드를 사용하여 파라미터를 바인딩할 때, 실제로는 SQL 문 자체에서 ? 플레이스홀더를 값으로 즉시 변경하는 것이 아니라, 
그 값을 내부적으로 유지하고 있다가 SQL 문을 실행할 때 데이터베이스와 통신하기 위해 바인딩합니다.

추가로 sql 인젝션을 막기위해 java에서는 https://owasp.org/www-community/attacks/SQL_Injection 의 내용을 반영해서 업데이트 된다.

---

[[section-202406-23일]]
23일
===

### 외부 호출을 트랜잭션과 묶을 때 주의점

실무를 하다보면 외부 서비스를 호출할 경우가 생긴다(대표적인게 결제). 
내부의 로직하고 엮어서 트랜잭션으로 묶어야 하는 상황이 필연적으로 생기는데 이때 주의해야 할 점이 있다.

1. **네트워크 에러 가능성**
   - 외부 서비스 호출 시 네트워크 에러가 발생할 가능성을 항상 염두에 두어야 한다. 
네트워크 상태가 불안정하거나 외부 서비스가 일시적으로 다운될 수 있기 때문에, 이러한 경우를 대비한 예외 처리가 필수적이다. 네트워크 에러가 발생하면 트랜잭션이 중단될 수 있으므로, 재시도 로직을 포함하거나 대체 경로를 마련하는 것이 중요하다.

2. **타임아웃 설정**
   - 외부 서비스를 호출할 때 타임아웃을 설정하는 것이 중요하다. 외부 서비스의 응답이 늦어질 경우, 트랜잭션이 무한정 대기 상태에 빠질 수 있기 때문이다. 적절한 타임아웃 설정을 통해 응답이 지연될 경우 트랜잭션을 롤백하거나 다른 처리를 할 수 있도록 해야 한다.
  특히 이경우는 외부 서비스 트랜잭션을 내부 서비스보다 먼저 호출하게될 경우 특히 조심하여야한다.

3. **재시도 로직**
   - 외부 서비스 호출이 실패했을 때 재시도할 수 있는 로직을 설계하는 것이 중요하다. 일시적인 네트워크 문제나 서비스 장애로 인한 실패를 대비해 일정 시간 후 재시도하는 로직을 구현할 수 있다. 단, 무한 재시도를 방지하기 위해 재시도 횟수나 시간을 제한하는 것이 좋다.

4. **일관성 유지**
 - 트랜잭션 내에서 외부 서비스 호출이 실패할 경우, 이를 적절히 처리할 수 있어야 한다. 예를 들어, 결제 서비스 호출이 실패할 경우 결제 내역을 취소하고 데이터베이스를 롤백하는 등의 처리가 필요하다. 이를 통해 데이터의 일관성을 유지할 수 있다.
  이 경우 외부서비스에 상태를 되돌리는 역함수를 호출하거나 롤백함수를 구현하여 처리하여야한다.

---

[[section-202406-27일]]
27일
===
### `explain` 값들 보는 법 간략 요약

`EXPLAIN`은 SQL 쿼리의 실행 계획을 보여주는 명령어이다, 쿼리의 성능을 분석하고 최적화하는 데 유용합니다.

- **id** : 쿼리의 순서 및 단계를 나타냅니다. 여러 단계로 이루어진 쿼리는 각 단계마다 다른 id를 가집니다.
- **select_type** : 쿼리의 유형을 나타냅니다. 예를 들어, `SIMPLE`(단순 SELECT), `PRIMARY`(메인 쿼리), `SUBQUERY`(서브쿼리) 등이 있습니다.
- **table** : 쿼리가 참조하는 테이블 이름을 나타냅니다.
- **type** : 조인의 유형을 나타냅니다. 성능이 좋은 순서대로 `system`, `const`, `eq_ref`, `ref`, `range`, `index`, `ALL` 등이 있습니다. `ALL` 은 테이블의 전체 스캔을 의미하며 성능이 가장 나쁩니다.
- **possible_keys** : 쿼리에서 사용할 수 있는 인덱스 목록을 나타냅니다.
- **key** : 실제로 사용된 인덱스를 나타냅니다.
- **key_len** : 사용된 인덱스의 길이를 나타냅니다. 인덱스가 얼마나 효과적으로 사용되는지 확인할 수 있습니다.
- **ref** : 인덱스와 비교할 열 또는 상수를 나타냅니다.
- **rows** : 쿼리가 처리할 것으로 예상되는 행의 수를 나타냅니다. 값이 클수록 쿼리의 비용이 높아집니다.
- **Extra** : 쿼리 실행에 대한 추가 정보를 제공합니다. 예를 들어, `Using index`, `Using temporary`, `Using filesort` 등이 있습니다. `Using filesort` 와 같은 항목은 성능 저하를 의미할 수 있습니다.






