// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202409]]
== 2024년 09월

[[section-202409-3일]]
3일
===
### epoll(linux) 이란?

epoll은 Linux 커널에서 제공하는 이벤트 기반 비동기 I/O 처리를 위한 메커니즘이다.
select나 poll과 같은 기존의 시스템 콜에서 발생하는 성능 저하 문제를 해결하기 위해 고안하였다.

#### epoll의 장점
* 성능 효율성: epoll은 **O(1)**의 성능을 보장한다. 모니터링할 파일 디스크립터의 수에 비례하여 성능이 저하되지 않아 다수의 파일 디스크립터를 모니터링할 때 매우 효율적이다.
* 이벤트 기반 방식: epoll은 **레벨 트리거(level-triggered)**와 엣지 트리거(edge-triggered) 두 가지 방식으로 동작할 수 있다.
** 레벨 트리거: 이벤트가 발생할 때마다 이를 처리
** 엣지 트리거: 이벤트가 한 번 발생하면 그에 대한 처리를 완료할 때까지 추가적인 이벤트를 발생시키지 않는 방식, 더 높은 성능을 기대할 수 있다.
* 적은 시스템 자원 사용: epoll은 반복적인 시스템 호출을 최소화하므로, CPU 및 메모리 자원 사용을 절감할 수 있습니다.
* 파일 디스크립터 제한 해소: select의 경우 감시할 수 있는 파일 디스크립터의 수가 제한되지만, epoll은 이 제한이 거의 없다. 이로 인해 수천~수만 개의 파일 디스크립터를 효율적으로 모니터링할 수 있다.

**epoll은 인터럽트와 관련 없다**
epoll은 FD(File Descriptor)에서 발생하는 i/o이벤트를 모니터링하는 메커니즘일뿐, 인터럽트와 직접적인 연관은 없다.


---

[[section-202409-9일]]
9일
===
### 탐욕알고리즘 최적해 조건
1. 탐욕스로운 선택 속성 : 앞의 선택이 뒤에 선택에 영향을 주지 않아야한다.
2. 최적 부분 구조 조건 : 문제의 최적해가 부분문제에서도 최적해여야한다.
이 두조건을 합쳐서 `매트로이드(Matroid)` 라고 한다.

---

[[section-202409-19일]]
19일
===
### 다익스트라 알고리즘
다익스트라 알고리즘은 단일 출발선에서 다른 모든 정점깢의 최단 경로를 찾는 알고리즘이다.
음의 가중치가 없다면 정확하게 동작한다.

알고리즘의 절차는 다음과 같다
1. 출발노드를 선택하고, 해당 노드까지의 거리를 0으로 설정한다. 나머지 노드는 무한으로 설정한다.
2. 처리되지 않은 노드 중 가장 작은 거리를 가진 노드를 선택한다.
3. 그 노드에 인접한 다른 노드로 가는 경로를 계산하고, 더 짧은 경로가 있으면 갱신한다.
4. 모든 노드에 이 과정을 반복한다


### 최소 신장 트리(Minimum Spanning Tree)


---

[[section-202409-23일]]
23일
===
### 파이프라인 해저드(Pipeline Hazard)
파이프라인 해저드(Pipeline Hazard)는 컴퓨터 아키텍처에서 파이프라인 방식으로 명령어를 처리할 때 발생할 수 있는 문제를 말한다.
파이프라인은 여러 명령어를 동시에 처리하여 CPU의 성능을 향상시키는 기술이지만 동시에 처리하다보니 다른 문제도 발생한다. (명령어간의 의존성문제, 자원 충돌문제, 등등)
이러한 문제를 파이프라인 해저드(Pipeline Hazard)라 하며 3가지 유형이 있다

#### 데이터 해저드 (Data Hazard)
*명령어 간에 데이터 의존성이 있어 발생하는 문제.* 
파이프라인에서는 명령어가 여러 단계로 나뉘어 동시 실행되므로, 이전 명령어가 아직 결과값을 완전히 계산하지 않은 상태에서 다음 명령어가 해당 값을 필요로 하면 문제가 발생한다.
데이터 해저드는 다시 세 가지가 있다:

RAW (Read After Write): 후속 명령어가 이전 명령어의 결과를 읽어야 할 때 발생.
WAR (Write After Read): 후속 명령어가 이전 명령어의 결과를 덮어쓰는 경우 발생.
WAW (Write After Write): 두 명령어가 같은 레지스터에 값을 쓸 때 발생.

#### 제어 해저드 (Control Hazard)
제어 해저드는 분기 명령어(예: if, for, while)로 인해 발생한다. 
분기 명령어가 실행되기 전에 다음에 실행할 명령어가 결정되지 않는 경우가 있는데, 이때 파이프라인은 어떤 명령어를 읽어와야 할지 예측해야한다. 
잘못된 분기 예측으로 인해 불필요한 명령어를 수행하게 되어 성능 저하가 발생할 수 있다.

#### 구조적 해저드 (Structural Hazard)
구조적 해저드는 하드웨어 자원을 동시에 사용해야 하는 경우 발생한다. 
예를 들어, 명령어를 수행할 때 여러 명령어가 동시에 같은 메모리 또는 동일한 연산 장치를 사용하려고 하면 자원 충돌이 발생할 수 있다. 
이로 인해 일부 명령어는 대기해야 하므로 파이프라인의 성능이 저하된다.

#### 해결하기 위한 방법
* 버블 삽입 (Bubble Insertion): 해저드가 발생할 경우 특정 단계에서 파이프라인을 잠시 멈추고 다음 명령어가 실행될 수 있도록 하는 방법.
* 포워딩 (Forwarding): 데이터 해저드를 해결하기 위해 이전 명령어의 결과값을 바로 다음 명령어로 전달하는 방식.
* 분기 예측 (Branch Prediction): 제어 해저드를 해결하기 위해 분기 명령어의 실행 결과를 예측하여 예측한 경로의 명령어를 미리 실행하는 방법.
* 파이프라인 인터리빙 (Pipeline Interleaving): 구조적 해저드를 줄이기 위해 여러 파이프라인을 병렬로 사용하는 방법.


---

[[section-202409-27일]]
27일
===
### 인터벌 스케줄링(Interval Scheduling)

인터벌 스케줄링(Interval Scheduling)은 주어진 시간 간격(interval)들이 겹치지 않도록 최대한 많은 개수를 선택하는 알고리즘이다. 
주요 목표는 일정 시간대에 여러 작업이나 이벤트가 있을 때, 최대한 많은 작업을 효율적으로 배치하여 처리하는 것이다.

**탐욕 알고리즘**(greedy algorithm)을 이용하여, 시작 시간과 종료 시간이 주어진 작업들 중 종료 시간이 가장 빠른 작업을 선택하는 방식이 대표적이다. 
이 과정을 반복하면서 서로 겹치지 않는 작업을 최대한 많이 선택할 수 있다. 

예를 들어, 각 작업이 A, B, C, D로 주어지고 그 작업들의 종료 시간이 빠른 순서대로 정렬하여 선택하는 것이 간단한 해결 방식이다.

---

[[section-202409-30일]]
30일
===
### 비트마스킹(Bit Masking)

AND연산 : 전부다 1이면 1, (ex a & b) 
OR연산 : 하나라도 1이면 1, (ex a | b) 
XOR연산 : 입력에서 1의 갯수가 홀수이면 출력이 1이다, (ex a ^ b)
NOT연산 : 비트를 반전시킨다, (ex ~0101 = 1010)
비트시프트 연산 : 
- 왼쪽 시프트: 0110 << 1 = 1100 → 비트를 왼쪽으로 이동
- 오른쪽 시프트: 0110 >> 1 = 0011 → 비트를 오른쪽으로 이동





