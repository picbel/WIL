// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202407]]
== 2024년 07월


[[section-202407-3일]]
3일
===
### LangChain

LangChain은 대규모 언어 모델(LLM)을 기반으로 애플리케이션을 구축하는 오픈 소스 프레임워크입니다. LLM은 대량의 데이터로 사전 훈련된 딥 러닝 모델로, 사용자 쿼리에 응답을 생성할 수 있습니다. LangChain은 이러한 모델의 응답을 맞춤화하고 정확성을 높이는 도구와 추상화를 제공합니다. 이를 통해 개발자는 프롬프트 체인을 만들거나 템플릿을 맞춤화하고, 모델을 재훈련 없이 새 데이터에 접근할 수 있도록 할 수 있습니다.

**LangChain의 중요성:**
LLM은 일반적인 쿼리에는 잘 대응하지만, 특정 분야에서는 성능이 떨어집니다. LangChain은 내부 데이터 소스와 통합하고 프롬프트 엔지니어링을 통해 이러한 문제를 해결합니다. 이를 통해 데이터 사이언티스트는 입력을 구체화하여 생성 모델의 응답을 개선할 수 있습니다.

**LangChain의 이점:**
1. **언어 모델 용도 변경:** 재훈련 없이 LLM을 다양한 분야에 맞게 사용할 수 있습니다.
2. **AI 개발 간소화:** 데이터 소스 통합과 프롬프트 세분화를 통해 AI 개발을 단순화합니다.
3. **개발자 지원:** 오픈 소스 커뮤니티의 지원을 받아 개발 시간을 단축할 수 있습니다.

**LangChain의 핵심 구성 요소:**
1. **LLM 인터페이스:** 다양한 모델과 상호작용할 수 있는 API를 제공합니다.
2. **프롬프트 템플릿:** 일관된 쿼리 형식을 제공하는 사전 구축된 구조입니다.
3. **에이전트:** 복잡한 애플리케이션을 위해 최적의 시퀀스를 결정하는 체인입니다.
4. **검색 모듈:** RAG 시스템을 설계할 수 있는 도구를 제공합니다.
5. **메모리:** 과거 상호작용을 기억하여 응답을 개선합니다.
6. **콜백:** 특정 이벤트를 로깅, 모니터링 및 스트리밍할 수 있는 코드입니다.

출처 : https://aws.amazon.com/ko/what-is/langchain/

---

[[section-202407-5일]]
5일
===

### 1:N 관계의 테이블을 대용량으로 조회할 때 주의할 점

물론 한꺼번에 많은 데이터를 가져오지 않고, 한번에 읽을 수 있는 크기를 정해서 잘라서 가져오는 것이 많은 경우에 해답이 되지만, 
그럼에도 불구하고 한번에 많은 양의 데이터를 가져오고 싶을 때 주의할 점을 이야기합니다.

1:N 관계를 조회할 때 (테이블의 모든 컬럼을 조회한다고 가정할 경우), 결과의 개수는 N의 합만큼 응답됩니다. 
인덱스가 잘 걸렸는지 여부와 관계없이 N 쪽에 의해 결과가 굉장히 커질 수 있다는 것을 항상 주의하며 쿼리해야 합니다.

예를 들어, A 테이블과 B 테이블이 있고, 관계는 A : B = 1:4~5 정도라 하겠습니다.

```sql
SELECT *
FROM A
JOIN B ON A.id = B.aId;
```

위 쿼리를 실행시킨다고 가정하면, 만약 A에서 5000행이 조회된다면 B는 45000행이 조회에 걸리고, 
결과적으로 응답은 45000행으로 오게 됩니다. 이럴 경우 예상보다 데이터가 커지기 때문에 인덱스를 잘 건다고 해도 느려질 수 있다. 

> 특히 쿼리의 실행중에 join 연산 과정이나 중간 결과를 저장하기위해 B(N)의 데이터에 A(1)의 데이터를 복사하여 메모리에 저장하는데 이 과정에서 memory copy가 일어난다.
> memory copy가 기본적으로 cpu보다는 느린 작업이라 자주 발생하면 굉장한 성능 저하가 올 수 있다.

따라서 다시 한 번 강조하지만, 쿼리의 크기를 조절해서 가져오는 것이 여러모로 좋은 방법이다.

---

[[section-202407-8일]]
8일
===
### TreeMap

Java의 TreeMap은 키-값 쌍을 저장하는 자료구조로, 키를 기준으로 정렬된 이진 탐색 트리 구조인 레드-블랙 트리를 유지한다. 
TreeMap의 주요 차별점은 자료구조 레벨에서 범위 검색을 지원하는 메서드들이 제공된다. 
예를 들어, subMap(), headMap(), tailMap() 메서드를 통해 특정 범위의 키를 손쉽게 검색할 수 있다.

코테에선 자주 쓰지만 실무에서는 자주 안써서 먼저떠오르는 자료구조는 아니라 이렇게 정의해봅니다

---

[[section-202407-11일]]
11일
===
### AVL Tree
AVL 트리(Adelson-Velsky and Landis Tree)는 자가 균형 이진 검색 트리이다.

#### 특징
1. **균형 조건**: 각 노드의 왼쪽 서브트리와 오른쪽 서브트리 높이 차이가 최대 1이어야 한다.
2. **균형 유지 방법**: 노드 삽입이나 삭제 시 균형이 깨지면 트리를 회전(rotations)하여 균형을 유지한다.
3. **회전 종류**: 단일 회전(Single Rotation)과 이중 회전(Double Rotation)이 있다.
   - 단일 회전: LL 회전, RR 회전
   - 이중 회전: LR 회전, RL 회전

#### 장점
- 균형이 잘 유지되어 검색, 삽입, 삭제 연산이 항상 O(log n) 시간 복잡도를 가진다.

#### 단점
- 삽입과 삭제 시 회전 연산이 많이 발생할 수 있어 실제 구현 및 유지보수가 복잡하다.

### Red-Black Tree
Red-Black 트리는 좀 더 완화된 균형 조건을 갖춘 자가 균형 이진 검색 트리입니다.

#### 특징
1. **노드 색상**: 각 노드는 빨간색(Red) 또는 검은색(Black)으로 색칠됩니다.
2. **균형 조건**:
   - 루트 노드는 항상 검은색입니다.
   - 모든 리프(NIL 노드)는 검은색입니다.
   - 빨간색 노드의 자식은 모두 검은색입니다(즉, 빨간색 노드가 연속으로 두 개 나올 수 없습니다).
   - 루트에서 모든 리프 노드까지의 경로에는 동일한 수의 검은색 노드가 있어야 합니다.
3. **균형 유지 방법**: 삽입과 삭제 시 색상 변경(recoloring)과 회전(rotations)을 통해 균형을 유지합니다.
4. **회전 종류**: 단일 회전(Single Rotation)과 이중 회전(Double Rotation)이 있습니다.

#### 장점
- 균형 조건이 덜 엄격하여 삽입과 삭제 연산 시 회전이 적게 발생하는 경향이 있습니다.
- 트리의 높이가 O(log n)으로 유지되어 검색, 삽입, 삭제 연산이 O(log n) 시간 복잡도를 가집니다.

#### 단점
- AVL 트리에 비해 검색 연산이 다소 비효율적일 수 있습니다.

### AVL Tree, Red-Black Tree 요약
AVL 트리와 Red-Black 트리는 둘 다 자가 균형 이진 검색 트리(self-balancing binary search tree)의 일종으로, 데이터의 삽입, 삭제, 검색 연산에서 최악의 경우에도 로그 시간 복잡도를 보장한다.
- **AVL 트리**는 더 엄격한 균형 조건을 유지하여 검색 연산이 빠를 수 있지만 삽입과 삭제 시 회전이 많이 발생할 수 있습니다.
- **Red-Black 트리**는 덜 엄격한 균형 조건을 유지하여 삽입과 삭제 시 회전이 적게 발생하며, 균형 유지가 좀 더 효율적일 수 있습니다.

---

[[section-202407-12일]]
12일
===
### Binary Search vs Prolly Search
https://www.dolthub.com/blog/2024-05-13-binary-vs-prolly/
위 블로그 포스트 내용 요약하기
