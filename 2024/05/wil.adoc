// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202405]]
== 2024년 05월

[[section-202405-3일]]
3일
===
### DAT (동적 메모리 주소 변환)

DAT(동적 메모리 주소 변환)는 OS가 가상 메모리 주소를 물리 메모리 주소로 변환하는 과정을 의미합니다.
이 과정은 MMU(메모리 관리 유닛)에 의해 수행됩니다.
MMU에서 페이지 테이블을 사용하여 가상 주소와 물리 주소를 맵핑합니다

#### TLB
- MMU 내부에는 TLB라는 캐시가 존재하는데, 이는 자주 사용되는 가상 주소의 변환 결과를 저장하여 변환 과정의 속도를 향상시킵니다.

#### Page Fault (페이지 폴트)
- 가상 주소로 접근할려는 주소가 물리 메모리(RAM)에 존재 하지 않을때 발생한다.

---
[[section-202405-4일]]
4일
===
### 메모리 오버레이

메모리 오버레이(Memory Overlay)는 프로그램의 일부를 메모리에 로드하고 나머지 부분은 필요할때 로드하는 방식으로 작동하는 기법을 말합니다.
메모리 용량이 제한된 시스템에서 큰 프로그램을 실행 할 수 있고, 메모리 사용향을 최적화 하여 효율적인 시스템 운영을 지원 가능하다

---
[[section-202405-10일]]
10일
===
### DMA 컨트롤러

DMA 컨트롤러란 I/O 요청을 처리할 때 CPU의 직접적인 개입없이 메모리에 데이터를 직접 읽거나 쓸 수 있도록 해주는 하드웨어 장치이다.
데이터 전송이 빈번하거나 대량인 경우 CPU의 부하를 줄여 성능 향상에 큰 도움을 준다.

---
[[section-202405-14일]]
14일
===
### Join 동작 방식

#### 중첩루프 조인  (Nested Loop Join)
가장 기본적인 조인 방식이다. 다음과 같이 동작한다

1. 외부 루프 : 한 테이블의 각 행에대해
2. 내부 루프 : 다른 테이블의 모든 행을 순차적으로 검색하여 조인 조건을 만족하는 행을 찾는다.

단순하지만, 두 테이블의 크기가 클 경우 매우 비효율적이다. 특히, 인덱스가 없다면 전체 테이블을 스캔(full scan)이 발생하여 성능이 떨어진다.

#### 블록 중첩 루프 조인 (Block Nested Loop Join)
위의 중첩루프 조인을 개선한 방식으로 다음과 같이 동작한다

1. 블록 처리 : 외부 테이블(Outer Table)의 여러 행을 한 번에 블록 단위로 읽습니다.
2. 내부 루프 : 각 블록에 대해 내부 테이블을 순차적으로 검색합니다.

블록 중첩 루프 조인은 외부 테이블의 여러 행을 한 번에 블록 단위로 읽고, 각 블록에 대해 내부 테이블(Inner Table)을 순차적으로 검색하는 방식으로 동작합니다, 일반 중첩 루프 조인보다 성능이 향상됩니다.
여전히 내부 테이블을 여러 번 읽어야 하므로, 내부 테이블에 인덱스가 있을 경우 성능이 크게 개선 될 수 있습니다.

성능 개선 요인은 다음과 같습니다

- I/O 오버헤드 감소 : 외부 테이블을 블록 단위로 읽음으로써 디스크 I/O 횟수가 줄어듭니다. 이는 특히 외부 테이블이 큰 경우에 유리합니다. 여러 행을 한 번에 읽기 때문에 I/O 효율성이 높아집니다.

- 캐시 효율성 증가 : 여러 행을 한 번에 메모리에 올려놓고 처리하기 때문에 캐시 효율성이 증가합니다. 메모리에 올린 블록을 반복해서 사용하므로, 메모리 접근 속도가 빨라집니다.

- 내부 테이블에 인덱스가 있을 경우 성능 향상 : 내부 테이블에 인덱스가 있으면, 블록 내의 각 행에 대해 내부 테이블의 특정 행을 빠르게 찾을 수 있습니다. 인덱스를 사용하여 검색 속도를 크게 향상시킬 수 있습니다.

#### 정렬병합 조인  (Sort-Merge Join)
두 테이블이 사전 정렬된 상태에서 사용되는 조인 방식이다. 다음과 같이 동작한다

1. 정렬 : 두 테이블을 조인 키를 기준으로 정렬합니다.
2. 병합 : 정렬된 두 테이블을 병합하여 조인 조건을 만족하는 행을 찾습니다.

정렬 병합 조인은 특히 큰 테이블에 적합하며, 인덱스가 없거나 조인 조건이 복잡한 경우에 효율적입니다. 사전 정렬이 필요하므로 정렬 비용이 추가될 수 있지만, 전체 테이블을 순차적으로 접근하기 때문에 효율적입니다.

#### 해시 조인 (Hash Join)
해시 조인은 해시 테이블을 이용하여 조인 조건을 만족하는 행을 찾는 방식이다. 주로 인덱스가 없는 큰 테이블에 사용됩니다. 다음과 같이 동작한다

1. 빌드 단계: 작은 테이블의 조인 키에 대해 해시 테이블을 생성합니다.
2. 프로브 단계: 큰 테이블의 각 행에 대해 해시 테이블을 조회하여 조인 조건을 만족하는 행을 찾습니다.

해시 조인은 특히 메모리 내에서 수행될 때 매우 빠르며, 큰 테이블의 조인에 적합합니다. 
메모리 제약이 있을 경우 디스크를 사용할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.

---
[[section-202405-17일]]
17일
===
### 복합 인덱스 생성시 고려사항
아래의 조건을 기준으로 순서를 나열하면 복합 인덱스의 효율이 증가한다.

1. 동일조건 : WHERE 절에서 동일 조건으로 자주 사용되는 열을 우선 포함합니다.
2. 범위조건 : 범위 조건으로 사용되는 열을 다음으로 포함합니다.
3. 정렬순서 : ORDER BY 절에서 자주 사용되는 열을 포함하여 정렬 작업을 최적화합니다.
4. 카디널리티 : 고유 값이 많은 열을 포함하여 인덱스의 선택성을 높입니다.

---
[[section-202405-20일]]
20일
===
### NAT

NAT(Network Address Translation, 네트워크 주소 변환)은 컴퓨터 네트워크에서 IP 주소를 변환하는 기술이다. 
이 기술은 주로 사설 네트워크와 공인 네트워크 간의 통신을 위해 사용된다.

#### 주요 기능

1. **IP 주소 절약**:
   - 사설 네트워크에서 많은 장치들이 공인 IP 주소 없이도 인터넷에 접속할 수 있게 한다.
   - 사설 IP 주소(예: 192.168.x.x, 10.x.x.x)를 사용하는 여러 장치가 NAT 라우터를 통해 하나의 공인 IP 주소를 공유하여 인터넷에 접속합니다.

2. **보안 강화**:
   - 내부 네트워크의 IP 주소를 숨겨 외부에서 직접 접근하는 것을 어렵게 만듭니다.
   - NAT는 일종의 방화벽 역할을 하여 외부에서 내부 네트워크로의 비인가 접근을 차단합니다.

3. **트래픽 관리**:
   - NAT는 트래픽을 제어하고 라우팅할 수 있습니다.
   - 특히 포트 포워딩이나 포트 트리거링과 같은 기능을 통해 특정 내부 장치로의 트래픽을 유도할 수 있습니다.

#### 유형

1. **정적 NAT (Static NAT)**:
   - 하나의 사설 IP 주소를 특정 공인 IP 주소에 고정적으로 매핑합니다.
   - 예를 들어, 내부 서버가 외부에서 특정 IP 주소로 항상 접근 가능하도록 설정할 때 사용합니다.

2. **동적 NAT (Dynamic NAT)**:
   - 사설 IP 주소를 공인 IP 주소 풀에서 동적으로 할당합니다.
   - 사설 네트워크의 장치가 인터넷에 접속할 때마다 공인 IP 주소가 할당됩니다.

3. **PAT (Port Address Translation, 포트 주소 변환)**:
   - 하나의 공인 IP 주소를 여러 장치가 공유할 수 있게 해줍니다.
   - 각 장치가 고유한 포트 번호를 사용하여 구분됩니다.
   - 흔히 "NAT 오버로드"라고도 불립니다.

#### 동작 원리

1. **출발지 IP 주소 변환**:
   - 내부 장치가 외부로 패킷을 보낼 때, NAT 라우터는 출발지 IP 주소를 사설 IP에서 공인 IP로 변환합니다.
   - 패킷이 목적지에 도착하면 출발지 IP 주소가 공인 IP 주소로 나타납니다.

2. **목적지 IP 주소 변환**:
   - 외부에서 내부 장치로 패킷이 도착할 때, NAT 라우터는 목적지 IP 주소를 공인 IP에서 사설 IP로 변환합니다.
   - 이렇게 함으로써 패킷이 올바른 내부 장치에 도달하게 됩니다.

#### 장단점

**장점**:
- 공인 IP 주소의 절약.
- 내부 네트워크의 보안 강화.
- 네트워크 관리의 유연성.

**단점**:
- 특정 애플리케이션에서의 호환성 문제 (예: VoIP, P2P).
- 네트워크 트래픽 분석의 어려움.
- 추가적인 지연 시간.


