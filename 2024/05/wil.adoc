// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202405]]
== 2024년 05월

[[section-202405-3일]]
3일
===
### DAT (동적 메모리 주소 변환)

DAT(동적 메모리 주소 변환)는 OS가 가상 메모리 주소를 물리 메모리 주소로 변환하는 과정을 의미합니다.
이 과정은 MMU(메모리 관리 유닛)에 의해 수행됩니다.
MMU에서 페이지 테이블을 사용하여 가상 주소와 물리 주소를 맵핑합니다

#### TLB
- MMU 내부에는 TLB라는 캐시가 존재하는데, 이는 자주 사용되는 가상 주소의 변환 결과를 저장하여 변환 과정의 속도를 향상시킵니다.

#### Page Fault (페이지 폴트)
- 가상 주소로 접근할려는 주소가 물리 메모리(RAM)에 존재 하지 않을때 발생한다.

---
[[section-202405-4일]]
4일
===
### 메모리 오버레이

메모리 오버레이(Memory Overlay)는 프로그램의 일부를 메모리에 로드하고 나머지 부분은 필요할때 로드하는 방식으로 작동하는 기법을 말합니다.
메모리 용량이 제한된 시스템에서 큰 프로그램을 실행 할 수 있고, 메모리 사용향을 최적화 하여 효율적인 시스템 운영을 지원 가능하다

---
[[section-202405-10일]]
10일
===
### DMA 컨트롤러

DMA 컨트롤러란 I/O 요청을 처리할 때 CPU의 직접적인 개입없이 메모리에 데이터를 직접 읽거나 쓸 수 있도록 해주는 하드웨어 장치이다.
데이터 전송이 빈번하거나 대량인 경우 CPU의 부하를 줄여 성능 향상에 큰 도움을 준다.

---
[[section-202405-14일]]
14일
===
### Join 동작 방식

#### 중첩루프 조인  (Nested Loop Join)
가장 기본적인 조인 방식이다. 다음과 같이 동작한다

1. 외부 루프 : 한 테이블의 각 행에대해
2. 내부 루프 : 다른 테이블의 모든 행을 순차적으로 검색하여 조인 조건을 만족하는 행을 찾는다.

단순하지만, 두 테이블의 크기가 클 경우 매우 비효율적이다. 특히, 인덱스가 없다면 전체 테이블을 스캔(full scan)이 발생하여 성능이 떨어진다.

#### 블록 중첩 루프 조인 (Block Nested Loop Join)
위의 중첩루프 조인을 개선한 방식으로 다음과 같이 동작한다

1. 블록 처리 : 외부 테이블(Outer Table)의 여러 행을 한 번에 블록 단위로 읽습니다.
2. 내부 루프 : 각 블록에 대해 내부 테이블을 순차적으로 검색합니다.

블록 중첩 루프 조인은 외부 테이블의 여러 행을 한 번에 블록 단위로 읽고, 각 블록에 대해 내부 테이블(Inner Table)을 순차적으로 검색하는 방식으로 동작합니다, 일반 중첩 루프 조인보다 성능이 향상됩니다.
여전히 내부 테이블을 여러 번 읽어야 하므로, 내부 테이블에 인덱스가 있을 경우 성능이 크게 개선 될 수 있습니다.

성능 개선 요인은 다음과 같습니다

- I/O 오버헤드 감소 : 외부 테이블을 블록 단위로 읽음으로써 디스크 I/O 횟수가 줄어듭니다. 이는 특히 외부 테이블이 큰 경우에 유리합니다. 여러 행을 한 번에 읽기 때문에 I/O 효율성이 높아집니다.

- 캐시 효율성 증가 : 여러 행을 한 번에 메모리에 올려놓고 처리하기 때문에 캐시 효율성이 증가합니다. 메모리에 올린 블록을 반복해서 사용하므로, 메모리 접근 속도가 빨라집니다.

- 내부 테이블에 인덱스가 있을 경우 성능 향상 : 내부 테이블에 인덱스가 있으면, 블록 내의 각 행에 대해 내부 테이블의 특정 행을 빠르게 찾을 수 있습니다. 인덱스를 사용하여 검색 속도를 크게 향상시킬 수 있습니다.

#### 정렬병합 조인  (Sort-Merge Join)
두 테이블이 사전 정렬된 상태에서 사용되는 조인 방식이다. 다음과 같이 동작한다

1. 정렬 : 두 테이블을 조인 키를 기준으로 정렬합니다.
2. 병합 : 정렬된 두 테이블을 병합하여 조인 조건을 만족하는 행을 찾습니다.

정렬 병합 조인은 특히 큰 테이블에 적합하며, 인덱스가 없거나 조인 조건이 복잡한 경우에 효율적입니다. 사전 정렬이 필요하므로 정렬 비용이 추가될 수 있지만, 전체 테이블을 순차적으로 접근하기 때문에 효율적입니다.

#### 해시 조인 (Hash Join)
해시 조인은 해시 테이블을 이용하여 조인 조건을 만족하는 행을 찾는 방식이다. 주로 인덱스가 없는 큰 테이블에 사용됩니다. 다음과 같이 동작한다

1. 빌드 단계: 작은 테이블의 조인 키에 대해 해시 테이블을 생성합니다.
2. 프로브 단계: 큰 테이블의 각 행에 대해 해시 테이블을 조회하여 조인 조건을 만족하는 행을 찾습니다.

해시 조인은 특히 메모리 내에서 수행될 때 매우 빠르며, 큰 테이블의 조인에 적합합니다. 
메모리 제약이 있을 경우 디스크를 사용할 수 있으며, 이는 성능에 영향을 줄 수 있습니다.

---
[[section-202405-17일]]
17일
===
### 복합 인덱스 생성시 고려사항
아래의 조건을 기준으로 순서를 나열하면 복합 인덱스의 효율이 증가한다.

1. 동일조건 : WHERE 절에서 동일 조건으로 자주 사용되는 열을 우선 포함합니다.
2. 범위조건 : 범위 조건으로 사용되는 열을 다음으로 포함합니다.
3. 정렬순서 : ORDER BY 절에서 자주 사용되는 열을 포함하여 정렬 작업을 최적화합니다.
4. 카디널리티 : 고유 값이 많은 열을 포함하여 인덱스의 선택성을 높입니다.

---
[[section-202405-20일]]
20일
===
### NAT

NAT(Network Address Translation, 네트워크 주소 변환)은 컴퓨터 네트워크에서 IP 주소를 변환하는 기술이다. 
이 기술은 주로 사설 네트워크와 공인 네트워크 간의 통신을 위해 사용된다.

#### 주요 기능

1. **IP 주소 절약**:
   - 사설 네트워크에서 많은 장치들이 공인 IP 주소 없이도 인터넷에 접속할 수 있게 한다.
   - 사설 IP 주소(예: 192.168.x.x, 10.x.x.x)를 사용하는 여러 장치가 NAT 라우터를 통해 하나의 공인 IP 주소를 공유하여 인터넷에 접속합니다.

2. **보안 강화**:
   - 내부 네트워크의 IP 주소를 숨겨 외부에서 직접 접근하는 것을 어렵게 만듭니다.
   - NAT는 일종의 방화벽 역할을 하여 외부에서 내부 네트워크로의 비인가 접근을 차단합니다.

3. **트래픽 관리**:
   - NAT는 트래픽을 제어하고 라우팅할 수 있습니다.
   - 특히 포트 포워딩이나 포트 트리거링과 같은 기능을 통해 특정 내부 장치로의 트래픽을 유도할 수 있습니다.

#### 유형

1. **정적 NAT (Static NAT)**:
   - 하나의 사설 IP 주소를 특정 공인 IP 주소에 고정적으로 매핑합니다.
   - 예를 들어, 내부 서버가 외부에서 특정 IP 주소로 항상 접근 가능하도록 설정할 때 사용합니다.

2. **동적 NAT (Dynamic NAT)**:
   - 사설 IP 주소를 공인 IP 주소 풀에서 동적으로 할당합니다.
   - 사설 네트워크의 장치가 인터넷에 접속할 때마다 공인 IP 주소가 할당됩니다.

3. **PAT (Port Address Translation, 포트 주소 변환)**:
   - 하나의 공인 IP 주소를 여러 장치가 공유할 수 있게 해줍니다.
   - 각 장치가 고유한 포트 번호를 사용하여 구분됩니다.
   - 흔히 "NAT 오버로드"라고도 불립니다.

#### 동작 원리

1. **출발지 IP 주소 변환**:
   - 내부 장치가 외부로 패킷을 보낼 때, NAT 라우터는 출발지 IP 주소를 사설 IP에서 공인 IP로 변환합니다.
   - 패킷이 목적지에 도착하면 출발지 IP 주소가 공인 IP 주소로 나타납니다.

2. **목적지 IP 주소 변환**:
   - 외부에서 내부 장치로 패킷이 도착할 때, NAT 라우터는 목적지 IP 주소를 공인 IP에서 사설 IP로 변환합니다.
   - 이렇게 함으로써 패킷이 올바른 내부 장치에 도달하게 됩니다.

#### 장단점

**장점**:
- 공인 IP 주소의 절약.
- 내부 네트워크의 보안 강화.
- 네트워크 관리의 유연성.

**단점**:
- 특정 애플리케이션에서의 호환성 문제 (예: VoIP, P2P).
- 네트워크 트래픽 분석의 어려움.
- 추가적인 지연 시간.

---
[[section-202405-24일]]
24일
===
### 클로저(Closure)

클로저에 대해 많은 설명이 있지만 가장 간단히 한줄로 요약하자면 다음과 같다
**클로저는 함수 내부에서 선언된 함수가 외부 함수의 변수에 접근할 수 있도록 하는 기능을 말합니다.**

#### Java와 Kotlin의 클로저 차이
Java의 경우에는 지역 변수 캡쳐시 final이거나 값에 변경이 없는 변수만 사용 가능하다. (자세한 설명은 지난번에 정리하였다 link:https://github.com/picbel/WIL/blob/main/2024/03/wil.adoc#%EC%A7%80%EC%97%AD-%EB%B3%80%EC%88%98-%EC%BA%A1%EC%B2%98[링크:지역변수캡쳐])
하지만 Kotlin의 경우에는 어떨까?
코틀린의 경우는 val, var 에 따라 달라지긴 한다.
val의 경우엔 final로 처리되어 지역변수캡쳐를 하지만 var은 좀 다르다
```kotlin
fun main() {
    var mutable = 0
    exampleFunction(lambda = { mutable++ })
}

fun exampleFunction(
    lambda: () -> Int
) {
    lambda()
}
```
위와 같은 코드를 디컴파일 하면 다음과 같다
```kotlin
public final class MainKt {
   public static final void main() {
      final Ref.IntRef mutable = new Ref.IntRef();
      mutable.element = 0;
      exampleFunction((Function0)(new Function0() {
         public Object invoke() {
            return this.invoke();
         }

         public final int invoke() {
            Ref.IntRef var10000 = mutable;
            int var1;
            var10000.element = (var1 = var10000.element) + 1;
            return var1;
         }
      }));
   }

   public static void main(String[] var0) {
      main();
   }

   public static final void exampleFunction(@NotNull Function0 lambda) {
      Intrinsics.checkNotNullParameter(lambda, "lambda");
      lambda.invoke();
   }
}
```
보면 IntRef라는 final static class로 래핑됩니다.
```kotlin
    public static final class IntRef implements Serializable {
        public int element;

        @Override
        public String toString() {
            return String.valueOf(element);
        }
    }

```
클래스로 맵핑되어 JVM 힙에 할당되기 때문에 메서드의 생명주기가 끝나도 영향받지 않습니다

---
[[section-202405-26일]]
26일
===
### 코루틴 - Stackful, Stackless

#### 스택풀 코루틴 (Stackful coroutine)

**특징:**
1. **독립된 스택:** 각 코루틴이 독립된 스택을 가지고 있습니다. 이는 코루틴이 호출 스택을 포함하여 모든 실행 상태를 유지한다는 것을 의미합니다.
2. **직접적인 컨텍스트 전환:** 스택풀 코루틴은 다른 코루틴으로 전환할 때 전체 호출 스택을 저장하고 복원할 수 있습니다. 이는 함수 호출이 깊게 중첩된 경우에도 코루틴이 적절히 작동할 수 있게 합니다.
3. **복잡한 제어 흐름:** 복잡한 함수 호출 및 제어 흐름을 쉽게 처리할 수 있습니다. 이는 일반적인 스레드와 유사하게 작동합니다.
4. **성능 오버헤드:** 스택풀 코루틴은 독립된 스택을 유지해야 하므로 메모리 오버헤드가 크며, 컨텍스트 전환 비용이 상대적으로 높을 수 있습니다.

**예시:**
- C++의 Boost.Coroutine 라이브러리
- Lua 프로그래밍 언어의 코루틴

#### 스택리스 코루틴 (Stackless coroutine)

**특징:**
1. **공유된 스택:** 스택리스 코루틴은 독립된 스택을 가지지 않으며, 호출 스택을 공유합니다. 이는 각 코루틴이 필요한 최소한의 상태 정보만 유지한다는 것을 의미합니다.
2. **제어 지점 유지:** 스택리스 코루틴은 특정 지점에서 실행을 일시 중단하고 나중에 재개할 수 있는 능력을 가지고 있습니다. 이는 주로 상태 머신과 유사하게 작동합니다.
3. **간단한 제어 흐름:** 일반적으로 간단한 제어 흐름을 처리하는 데 적합합니다. 깊게 중첩된 함수 호출에는 적합하지 않습니다.
4. **저렴한 오버헤드:** 스택리스 코루틴은 메모리 오버헤드와 컨텍스트 전환 비용이 상대적으로 적습니다.

**예시:**
- Kotlin의 Coroutine
- Python의 asyncio
- C#의 async/await
- JavaScript의 async/await

### 비교

- **메모리 사용량:** 스택풀 코루틴은 각 코루틴마다 독립된 스택을 가지므로 메모리 사용량이 높습니다. 반면, 스택리스 코루틴은 필요한 최소한의 상태만 유지하므로 메모리 사용량이 적습니다.
- **컨텍스트 전환 비용:** 스택풀 코루틴은 컨텍스트 전환 비용이 높지만, 스택리스 코루틴은 비용이 낮습니다.
- **복잡한 함수 호출 처리:** 스택풀 코루틴은 깊게 중첩된 함수 호출을 잘 처리할 수 있는 반면, 스택리스 코루틴은 제한적입니다.
- **구현 복잡도:** 스택풀 코루틴의 구현은 더 복잡할 수 있으며, 특히 다양한 플랫폼에서의 스택 관리가 까다롭습니다. 스택리스 코루틴은 구현이 상대적으로 간단합니다.

현재 작성중
---
[[section-202405-29일]]
29일
===
### 클러스터링된 DB 구조에서 외부 Table을 이용한 join이 가능하다
작성중
