// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:

---
https://github.com/picbel/WIL/blob/main/2025/06/wil.adoc[이전 달]
https://github.com/picbel/WIL/blob/main/2025/08/wil.adoc[다음 달]

[[section-202507]]
== 2025년 7월

[[section-202507-5일]]
5일
===
### Spring application에서 초기화 로직 등록

스프링에서 애플리케이션이 최초로 시작될 때 한번만 실행되기 위한 초기화 로직이 필요한 경우가 있다.
이때 가장 권장되는 방식이 `@EventListener(ApplicationReadyEvent.class)` 방식이다
```kotlin
@Component
class WarmUpRunner {

    @EventListener(ApplicationReadyEvent::class)
    fun onApplicationReady() {
        // 앱 시작 후 실행할 로직 (웜업, 캐시 적재 등)
        println("애플리케이션 준비 완료. 웜업 시작.")
    }
}
```
ApplicationReadyEventsms Spring Application이 완전히 초기화된 후** 실행된다.
@PostConstruct보다 **모든 Bean이 준비된 이후**이므로 더 안전하다.

다른방법들과 간단 요약
[cols="3,3,4", options="header"]
|===
| 어노테이션 / 방식
| 실행 시점
| 적합한 용도

| `@EventListener(ApplicationReadyEvent.class)`
| 모든 빈 로딩 완료 후
| 웜업, 캐시 적재 등 초기화 로직

| `@PostConstruct`
| 빈 생성 직후
| 간단한 필드 초기화 용도에 적합

| `CommandLineRunner` / `ApplicationRunner`
| 애플리케이션 시작 직후(모든 빈이 초기화되었다는걸 보장하지 않는다.)
| 커맨드라인 기반 초기화
|===


---
[[section-202507-11일]]
11일
===
### Java의 Seald, Permits, non-sealed

Java 17부터 지원하는 Seald, Permits, non-sealed

#### Sealed 클래스/인터페이스 (sealed)
- 특정 클래스나 인터페이스가 누가 상속/구현할 수 있는지 제한한다.
- extends/implements 가능한 하위 타입을 명시적으로 permits 절에서 선언해야 한다.
- 목적: 상속 계층을 통제해서 안전한 패턴 매칭, 유지보수 용이성을 보장.

```java
public sealed class Shape permits Circle, Rectangle, Triangle {
    // ...
}
```

#### Permits (permits)
- sealed 클래스나 인터페이스의 허용된 하위 클래스/인터페이스를 나열한다.
- 하위 클래스들은 반드시 같은 모듈(모듈 시스템 사용 시), 같은 패키지(모듈 시스템 미사용 시) 안에 존재해야 합니다.

```java
public sealed interface Animal permits Dog, Cat { }

final class Dog implements Animal { }
final class Cat implements Animal { }
```

#### Non-sealed (non-sealed)
- sealed 계층에 속하지만, 더 이상 제한을 두지 않고 자유롭게 상속 가능하게 만든다.
- sealed와 final의 중간 역할. 즉, 특정 타입까지만 제한하고, 그 밑에서는 확장 자유를 허용.
```java
public sealed class Vehicle permits Car, Bus { }

public final class Car extends Vehicle { }       // 더 확장 불가
public non-sealed class Bus extends Vehicle { }  // Bus는 누구든 상속 가능
```

---
[[section-202507-13일]]
13일
===
### synchronized 락 대상 별 범위 정리
**같은 `lock` 객체를 공유**해야만 동기화 효과가 있습니다.

1) `synchronized(instance) { ... }` — 특정 객체 인스턴스를 락으로 사용
```java
class Locker {
    private int count = 0;
    void doWork(Object lock) {
        // lock 인스턴스가 같은 경우에만 상호배제
        synchronized (lock) {
            count++;
            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
            System.out.println(Thread.currentThread().getName() + " -> " + count);
        }
    }
}

public class Ex1 {
    public static void main(String[] args) {
        Locker svc = new Locker();
        Object shared = new Object();
        Object other = new Object();

        // T1/T2는 같은 lock(shared) 사용 → 직렬화됨
        new Thread(() -> svc.doWork(shared), "T1").start();
        new Thread(() -> svc.doWork(shared), "T2").start();

        // T3은 다른 lock(other) → T1/T2와 동시 실행 가능
        new Thread(() -> svc.doWork(other), "T3").start();
    }
}
```


2) `synchronized static method` — 클래스 객체(모듈 전체) 단위 락
**같은 클래스**의 모든 스레드가 **하나의 락**을 공유합니다.

```java
class GlobalCounter {
    private static int total = 0;

    public static synchronized void add() { // 클래스 객체에 락
        total++;
        try { Thread.sleep(50); } catch (InterruptedException ignored) {}
        System.out.println(Thread.currentThread().getName() + " -> total=" + total);
    }
}

public class Ex2 {
    public static void main(String[] args) {
        // 인스턴스가 달라도 같은 클래스면 동일 락 공유
        new Thread(GlobalCounter::add, "A").start();
        new Thread(GlobalCounter::add, "B").start();
    }
}
```

3) `synchronized instance method` — 해당 인스턴스(this) 단위 락
**인스턴스별로 락 분리**가 필요할 때 사용합니다.

```java
class Counter {
    private int value = 0;

    public synchronized void inc() { // this에 락
        value++;
        try { Thread.sleep(50); } catch (InterruptedException ignored) {}
        System.out.println(Thread.currentThread().getName() + " -> value=" + value);
    }
}

public class Ex3 {
    public static void main(String[] args) {
        Counter a = new Counter();
        Counter b = new Counter();

        // 같은 인스턴스 a를 동시에 호출 → 직렬화
        new Thread(a::inc, "A1").start();
        new Thread(a::inc, "A2").start();

        // 다른 인스턴스 b에서는 동시에 진행 가능 (락 별개)
        new Thread(b::inc, "B1").start();
    }
}
```

4) `synchronized(SomeClass.class)` — 클래스 객체를 명시적으로 락으로 사용
`synchronized static method`와 같은 **클래스 단위 락**입니다.

```java
class ClassWide {
    static void work() {
        synchronized (ClassWide.class) { // static 메서드 락과 동일 대상
            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
            System.out.println(Thread.currentThread().getName() + " in class-wide lock");
        }
    }
}

public class Ex4 {
    public static void main(String[] args) {
        new Thread(ClassWide::work, "X").start();
        new Thread(ClassWide::work, "Y").start();
    }
}
```

5) `synchronized(this) { ... }` — 현재 인스턴스를 락으로 사용
내부 블록에서 **명시적으로 this를 락**으로 사용할 때.

```java
class ThisLocker {
    void doWork() {
        synchronized (this) { // instance method의 synchronized와 동일 대상
            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
            System.out.println(Thread.currentThread().getName() + " on this");
        }
    }
}

public class Ex5 {
    public static void main(String[] args) {
        ThisLocker obj = new ThisLocker();
        new Thread(obj::doWork, "T1").start();
        new Thread(obj::doWork, "T2").start(); // T1과 직렬화
    }
}
```

6) `synchronized(lockObj) { ... }` — 전용 락 객체로 범위/충돌 분리
전용 락 객체를 분리해 **충돌 범위를 최소화**할 수 있습니다.
주의: **`String` 리터럴, 오토박싱 Integer** 등을 락으로 쓰면 **인터닝/캐싱**으로 예기치 않은 공유가 발생할 수 있으니 \*\*전용 `new Object()`\*\*를 사용해야합니다.

```java
class FineGrainedService {
    private final Object readLock  = new Object();
    private final Object writeLock = new Object();

    void readOp() {
        synchronized (readLock) {
            // 읽기계열 임계구역
            System.out.println(Thread.currentThread().getName() + " read");
        }
    }

    void writeOp() {
        synchronized (writeLock) {
            // 쓰기계열 임계구역 (read와 충돌 안 함)
            System.out.println(Thread.currentThread().getName() + " write");
        }
    }
}

public class Ex6 {
    public static void main(String[] args) {
        FineGrainedService s = new FineGrainedService();
        new Thread(s::readOp,  "R1").start();
        new Thread(s::readOp,  "R2").start();
        new Thread(s::writeOp, "W1").start();
    }
}
```

[cols="3,3,6", options="header"]
|===
| 위치
| 락 대상
| 설명

| `synchronized(instance) { }`
| **해당 객체(instance)**
| 같은 인스턴스를 공유할 때만 상호배제. 인스턴스가 다르면 동시 실행 가능.

| `synchronized static method`
| **클래스 객체(Class.class)**
| 클래스 단위 락. 인스턴스가 달라도 동일 클래스면 직렬화.

| `synchronized instance method`
| **해당 인스턴스(this)**
| 인스턴스 단위 락. 인스턴스별로 병렬성 확보 가능.

| `synchronized(SomeClass.class)`
| **클래스 객체(SomeClass.class)**
| 클래스 단위 명시적 락. static 메서드와 동일 대상.

| `synchronized(this) { }`
| **현재 인스턴스**
| 블록 범위에서 this를 락으로 사용. instance method의 synchronized와 동일 대상.

| `synchronized(lockObj) { }`
| **명시한 lock 객체**
| 전용 락으로 충돌 범위를 세분화. `new Object()` 등 별도 락 권장(문자열/오토박싱 객체 사용 지양).
|===



