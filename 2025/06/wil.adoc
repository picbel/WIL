// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:

---
https://github.com/picbel/WIL/blob/main/2025/05/wil.adoc[이전 달]
https://github.com/picbel/WIL/blob/main/2025/07/wil.adoc[다음 달]

[[section-202506]]
== 2025년 6월

[[section-202506-7일]]
7일
===
### TC/C (Try-Confirm/Cancel) 시도-확정/취소

`TC/C`(Try-Confirm/Cancel)는 **분산 트랜잭션**을 다룰 때 사용하는 트랜잭션 패턴 중 하나이다.
2PC(2-Phase Commit)의 단점을 보완하기 위한 **보상 기반 트랜잭션** 설계 방식
주로 마이크로서비스 아키텍처(MSA)에서 각 서비스의 로컬 트랜잭션을 분리하면서도 **전체 트랜잭션 정합성**을 유지하고자 할 때 사용한다 .


TC/C는 각 단계가 다음처럼 구성됨:
[cols="1,3", options="header"]
|===
| 단계 | 설명

| *Try*
| 자원의 *예약* 혹은 *검증* 단계 (ex. 재고 수량 확보, 금액 확인). 실제 커밋은 아직 발생하지 않음.

| *Confirm*
| 모든 서비스가 Try에 성공했을 때 실행됨. 각 서비스는 *예약한 작업을 실제로 수행* (커밋).

| *Cancel*
| 일부 서비스가 Try에 실패했거나, 전체 트랜잭션이 중단될 경우, 이전에 했던 Try 작업을 *롤백 또는 무효화*함.
|===


* 장점 
** 2PC보다 유연하고 서비스 간 결합도 낮음
** 장애 복구나 재시도에 강함
** 로컬 트랜잭션 기반으로 성능 유리
* 단점
** 각 서비스에 **Try/Confirm/Cancel API를 모두 구현**해야 함
** 자원 예약 상태를 명확하게 관리해야 하며
** 취소 로직도 중요함


사용 예시: 항공권 예매
예를 들어 항공권 예약 시, 좌석 확보와 결제는 각각 다른 서비스가 처리한다.

1. **Try 단계**
   * 좌석 서비스 → 해당 좌석 "예약 상태"로 변경
   * 결제 서비스 → 결제 가능한지 카드 한도 확인 및 금액 임시 홀딩

2. **Confirm 단계**
   * 좌석 → 예약 확정
   * 결제 → 실제 결제 수행

3. **Cancel 단계**
   * 좌석 → 예약 해제
   * 결제 → 홀딩된 금액 해제


#### TC/C vs 2PC vs Saga 비교 요약

[cols="1,1,1,1", options="header"]
|===
| 항목     | TC/C                | 2PC              | Saga

| 패턴     | 보상 기반             | 원자 커밋         | 보상 기반
| 성격     | 명시적 예약 → 확정 or 취소 | 글로벌 커밋/롤백 | 각 서비스에 보상 트랜잭션 정의
| 분산락    | 필요 없음             | 필요함           | 필요 없음
| 장애 복구  | 강함                | 약함              | 강함
| 구현 복잡도 | 높음                | 중간              | 중간
|===

사용 팁
* **예약 상태**는 타임아웃, 만료 시간 등을 정해 자동 취소 로직이 필요합니다.
* 데이터 정합성보다 최종 일관성(Eventual Consistency)을 추구하는 환경에 적합합니다.
* 네트워크 지연, 재시도, Cancel 실패 등에 대한 **재처리 메커니즘**도 반드시 고려해야 합니다.

---

[[section-202506-14일]]
14일
===
### 타임아웃의 종류 정의

[cols="1,2,2,2", options="header"]
|===
| 종류 | 설명 | 예시 | 특징

| *Connection Timeout*
| 서버나 대상 시스템에 *연결을 시도할 때까지의 제한 시간*
| 클라이언트가 서버 IP로 접속 시도하는데 5초 이상 응답이 없으면 중단
| API 호출 전에 연결이 실패한 경우로, 재시도 부담이 적고 일반적으로 멱등성 고려 없이 재시도 가능.  
  네트워크 또는 DNS 문제일 가능성도 있음.

| *Read Timeout*
| 연결된 후, *응답 데이터를 기다리는 최대 시간*
| HTTP 요청 후 3초간 응답이 안 오면 실패 처리
| API는 호출되어 기능 수행 중 실패된 경우이므로 재시도 시 *멱등성* 또는 *중복 처리 여부* 확인 필요.  
  처리 시간이 긴 API에 대해 적절한 timeout 설정이 중요.

| *Write Timeout*
| 데이터를 *전송(write)* 할 때 기다리는 최대 시간
| 대용량 업로드가 10초 이상 지연될 경우 중단
| 일반적으로 POST/PUT처럼 요청 body가 포함된 API 호출에서 발생.
  요청 데이터를 서버로 전송하는 도중 타임아웃이 발생하면, 서버가 일부 데이터를 수신했거나 이미 처리를 시작했을 수 있어 요청의 처리 여부가 불확실해진다.
  재시도 시 중복 처리나 데이터 불일치(부분 처리) 문제가 발생할 수 있으며, 이를 방지하기 위해 멱등성 보장, 요청 ID(Idempotency Key) 사용, 또는 청크 단위 전송 및 재전송 전략이 필요합니다.

| *Idle Timeout*
| 연결된 후, *아무 작업도 하지 않은 채 유지되는 최대 시간*
| 웹소켓이나 커넥션 풀에서 일정 시간 동안 요청이 없으면 연결 종료
| 자원 효율화를 위한 타임아웃.  
  일정 시간 후 자동 연결 종료되므로, 장기 연결(웹소켓 등)에서는 주기적인 ping/pong 유지 필요.

| *Execution Timeout*
| 특정 코드 블록이나 *작업 처리에 주어진 최대 실행 시간*
| 배치 작업이 1분 넘게 걸리면 강제 종료
| 서버 내부에서 수행되는 연산/로직의 최대 허용 시간.  
  과도한 부하, 무한 루프, 외부 호출 지연 등 방지를 위한 보호장치.  
  트랜잭션 단위로 설정되기도 하며, timeout 시 *부분 실패 처리 전략* 필요.
|===

---

[[section-202506-18일]]
18일
===
### CDC 란?

---

[[section-202506-24일]]
24일
===
### Request Collapsing

