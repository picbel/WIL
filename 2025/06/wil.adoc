// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:

---
https://github.com/picbel/WIL/blob/main/2025/05/wil.adoc[이전 달]
https://github.com/picbel/WIL/blob/main/2025/07/wil.adoc[다음 달]

[[section-202506]]
== 2025년 6월

[[section-202506-7일]]
7일
===
### TC/C (Try-Confirm/Cancel) 시도-확정/취소

`TC/C`(Try-Confirm/Cancel)는 **분산 트랜잭션**을 다룰 때 사용하는 트랜잭션 패턴 중 하나이다.
2PC(2-Phase Commit)의 단점을 보완하기 위한 **보상 기반 트랜잭션** 설계 방식
주로 마이크로서비스 아키텍처(MSA)에서 각 서비스의 로컬 트랜잭션을 분리하면서도 **전체 트랜잭션 정합성**을 유지하고자 할 때 사용한다 .


TC/C는 각 단계가 다음처럼 구성됨:
[cols="1,3", options="header"]
|===
| 단계 | 설명

| *Try*
| 자원의 *예약* 혹은 *검증* 단계 (ex. 재고 수량 확보, 금액 확인). 실제 커밋은 아직 발생하지 않음.

| *Confirm*
| 모든 서비스가 Try에 성공했을 때 실행됨. 각 서비스는 *예약한 작업을 실제로 수행* (커밋).

| *Cancel*
| 일부 서비스가 Try에 실패했거나, 전체 트랜잭션이 중단될 경우, 이전에 했던 Try 작업을 *롤백 또는 무효화*함.
|===


* 장점 
** 2PC보다 유연하고 서비스 간 결합도 낮음
** 장애 복구나 재시도에 강함
** 로컬 트랜잭션 기반으로 성능 유리
* 단점
** 각 서비스에 **Try/Confirm/Cancel API를 모두 구현**해야 함
** 자원 예약 상태를 명확하게 관리해야 하며
** 취소 로직도 중요함


사용 예시: 항공권 예매
예를 들어 항공권 예약 시, 좌석 확보와 결제는 각각 다른 서비스가 처리한다.

1. **Try 단계**
   * 좌석 서비스 → 해당 좌석 "예약 상태"로 변경
   * 결제 서비스 → 결제 가능한지 카드 한도 확인 및 금액 임시 홀딩

2. **Confirm 단계**
   * 좌석 → 예약 확정
   * 결제 → 실제 결제 수행

3. **Cancel 단계**
   * 좌석 → 예약 해제
   * 결제 → 홀딩된 금액 해제


#### TC/C vs 2PC vs Saga 비교 요약

[cols="1,1,1,1", options="header"]
|===
| 항목     | TC/C                | 2PC              | Saga

| 패턴     | 보상 기반             | 원자 커밋         | 보상 기반
| 성격     | 명시적 예약 → 확정 or 취소 | 글로벌 커밋/롤백 | 각 서비스에 보상 트랜잭션 정의
| 분산락    | 필요 없음             | 필요함           | 필요 없음
| 장애 복구  | 강함                | 약함              | 강함
| 구현 복잡도 | 높음                | 중간              | 중간
|===

사용 팁
* **예약 상태**는 타임아웃, 만료 시간 등을 정해 자동 취소 로직이 필요합니다.
* 데이터 정합성보다 최종 일관성(Eventual Consistency)을 추구하는 환경에 적합합니다.
* 네트워크 지연, 재시도, Cancel 실패 등에 대한 **재처리 메커니즘**도 반드시 고려해야 합니다.

---

[[section-202506-14일]]
14일
===
### 타임아웃의 종류 정의

[cols="1,2,2,2", options="header"]
|===
| 종류 | 설명 | 예시 | 특징

| *Connection Timeout*
| 서버나 대상 시스템에 *연결을 시도할 때까지의 제한 시간*
| 클라이언트가 서버 IP로 접속 시도하는데 5초 이상 응답이 없으면 중단
| API 호출 전에 연결이 실패한 경우로, 재시도 부담이 적고 일반적으로 멱등성 고려 없이 재시도 가능.  
  네트워크 또는 DNS 문제일 가능성도 있음.

| *Read Timeout*
| 연결된 후, *응답 데이터를 기다리는 최대 시간*
| HTTP 요청 후 3초간 응답이 안 오면 실패 처리
| API는 호출되어 기능 수행 중 실패된 경우이므로 재시도 시 *멱등성* 또는 *중복 처리 여부* 확인 필요.  
  처리 시간이 긴 API에 대해 적절한 timeout 설정이 중요.

| *Write Timeout*
| 데이터를 *전송(write)* 할 때 기다리는 최대 시간
| 대용량 업로드가 10초 이상 지연될 경우 중단
| 일반적으로 POST/PUT처럼 요청 body가 포함된 API 호출에서 발생.
  요청 데이터를 서버로 전송하는 도중 타임아웃이 발생하면, 서버가 일부 데이터를 수신했거나 이미 처리를 시작했을 수 있어 요청의 처리 여부가 불확실해진다.
  재시도 시 중복 처리나 데이터 불일치(부분 처리) 문제가 발생할 수 있으며, 이를 방지하기 위해 멱등성 보장, 요청 ID(Idempotency Key) 사용, 또는 청크 단위 전송 및 재전송 전략이 필요합니다.

| *Idle Timeout*
| 연결된 후, *아무 작업도 하지 않은 채 유지되는 최대 시간*
| 웹소켓이나 커넥션 풀에서 일정 시간 동안 요청이 없으면 연결 종료
| 자원 효율화를 위한 타임아웃.  
  일정 시간 후 자동 연결 종료되므로, 장기 연결(웹소켓 등)에서는 주기적인 ping/pong 유지 필요.

| *Execution Timeout*
| 특정 코드 블록이나 *작업 처리에 주어진 최대 실행 시간*
| 배치 작업이 1분 넘게 걸리면 강제 종료
| 서버 내부에서 수행되는 연산/로직의 최대 허용 시간.  
  과도한 부하, 무한 루프, 외부 호출 지연 등 방지를 위한 보호장치.  
  트랜잭션 단위로 설정되기도 하며, timeout 시 *부분 실패 처리 전략* 필요.
|===

---

[[section-202506-18일]]
18일
===
### CDC 란?
CDC(Change Data Capture)는 시스템 내부에서 발생한 데이터 변경을 추적하는 모든 방식이다.
주로 데이터베이스에서 발생한 변경 사항(삽입, 수정, 삭제)을 실시간 또는 근실시간으로 감지하여 외부 시스템으로 전달하는 기술이다.
이 기술은 데이터 동기화, 이벤트 기반 아키텍처, ETL 최적화, 마이크로서비스 간 데이터 연동 등에 핵심적으로 활용된다.

기존에는 배치(Batch) 방식으로 주기적으로 데이터를 동기화하는 방식이 일반적이었지만, 다음과 같은 한계가 있다:

- 데이터 지연(latency): 변경 후 반영까지 시간이 오래 걸림
- 리소스 낭비: 매번 전체 데이터를 비교해야 하므로 비효율적
- 실시간 처리 불가능: 실시간 분석, 이벤트 기반 시스템에 부적합

CDC는 이러한 문제를 해결하기 위해 쓰인다.

#### CDC 방식의 종류
CDC는 구현 방식에 따라 다음과 같이 구분됩니다:

1. 쿼리 기반 (Query-Based)
주기적으로 updated_at 같은 타임스탬프 컬럼을 조회하여 변경사항을 추적
장점: 별도 설정 없이 간단하게 도입 가능
단점: 누락/중복 가능성 있음, DB에 부하 발생

2. 트리거 기반 (Trigger-Based)
DB 트리거를 활용해 변경 이벤트 발생 시 별도 로그 테이블에 기록
장점: 정확하고 실시간 감지 가능
단점: DB 성능 영향, 유지보수 어려움

3. 로그 기반 (Log-Based, WAL 기반)
DB의 트랜잭션 로그(Write-Ahead Log)를 직접 읽어 변경사항 감지
장점: 성능 저하 없음, 누락 가능성 없음, 실시간 처리 가능
단점: 설정 복잡, 로그 포맷 DB마다 상이(ex mysql일 경우 binlog, PostgreSQL의 경우 WAL)

가장 일반적으로 사용하는 방법은 로그 기반 CDC이며, 실시간성과 정확성을 모두 만족한다.

**CDC 실전 예시: Debezium + Kafka**
CDC를 실무에서 적용할 때 대표적인 구성은 다음과 같다:

- Debezium: 오픈소스 CDC 커넥터. MySQL, PostgreSQL 등 다양한 DB의 로그를 분석하여 Kafka로 메시지를 전송
- Kafka: 변경 이벤트를 실시간 스트림으로 전달. downstream 시스템에서 구독하여 처리
- Sink Connector: 변경 이벤트를 Elasticsearch, Redis, 다른 DB 등으로 전달

`[ MySQL ] ---> [ Debezium ] ---> [ Kafka ] ---> [ 실시간 처리 시스템 / 캐시 / 검색엔진 ]`

**CDC를 적용할 때 고려할 점**

- DB 로그 접근 권한: 로그 기반은 DB에 대한 권한이 필요
- Schema 변화 감지: 스키마 변경도 함께 감지하고 반영할 수 있는 체계가 필요
- 멱등성 보장: downstream 시스템에서 중복 처리를 피하기 위한 처리
- 정합성 검증: 이벤트 유실이나 순서 꼬임 방지를 위한 설계 필요

---

[[section-202506-24일]]
24일
===
### Request Collapsing
Request Collapsing(요청병합)은 짧은 시간 동안 동일한 요청이 여러 번 들어왔을 때, 이를 하나로 묶어(back) 한 번만 처리한 후, 그 결과를 여러 요청에 동일하게 전달하는 기법이다.

고부하 또는 고빈도 요청 시스템에서 다음과 같은 문제를 막기 위해 사용됩니다:

- 리소스 낭비 감소: 동일한 백엔드 호출을 반복하지 않음
- 트래픽 폭주 방지: 특히 캐시가 비었을 때 동시 요청이 몰리는 상황에서 효과적 (cache stampede 방지)
- 응답 시간 최적화: 최초 요청 하나만 처리되므로 나머지는 대기 후 바로 결과 수신

동작 방식 예시
```plaintext
      [ 클라이언트 3명 ]
   |        |        |
   v        v        v
 GET /product/123  (3건 동시)
   \       |       /
    \      |      /
     --> [Request Collapser]
               |
        1회 DB 조회 or API 호출
               |
         결과를 모두에게 반환
```

보통 실무에선 다음과 같이 많이 쓴다.

1. Netflix Hystrix의 Request Collapser
  Hystrix는 Collapser 기능을 통해 request collapsing을 지원
  내부적으로 batching + deduplication 수행
2. Spring + Guava Cache + Future
  Future, CompletableFuture로 요청 결과를 공유하거나,
  Guava CacheLoader에서 동일 키의 로딩 병합 지원

사용시 주의점은
1. 동일성 판단 기준이 명확해야 함 (URL, 파라미터 등으로 key 생성)
2. 대기 시간 trade-off 존재: 최초 요청 결과가 나올 때까지 기다려야 함
3. 타이밍 윈도우 설정이 중요 (얼마나 짧은 시간 안의 요청을 병합할 것인지)

#### Cacheing과 차이점
Request Collapsing과 cacheing의 차이점은 리소스 절약의 관점이 크다.
캐싱은 결과자체만을 저장하고 반환하지만 가령 이미지생성, 외부 환율 API같이 실시간 계산이 필요한데 동일 요청이 집중되는 상황
→ 캐싱은 못 쓰지만 중복 호출은 줄이고 싶을 때 사용한다.

#### Request Batching과 차이점
[cols="1,2,2", options="header"]
|===
| 구분
| Request Collapsing
| Request Batching

| 목적
| 중복 요청 제거 (Deduplication)
| 여러 요청을 묶어서 처리량 최적화 (Bulk 처리)

| 트리거
| 동일한 요청이 짧은 시간에 여러 번 들어옴
| 여러 요청이 동시에 들어오거나 일정량 쌓임

| 입력 요청들
| 모두 동일한 요청
| 서로 다른 요청들

| 사용 사례
| 동일 리소스에 중복 요청 → 하나로 병합
| 여러 ID에 대한 조회 → 한 쿼리로 묶음

| 결과 반환 방식
| 하나의 결과를 모두에게 공유
| 각각의 요청에 대해 개별 결과 반환

| 예시
| GET /product/123가 동시에 10건 → 하나로 묶어 조회 → 결과 1개 → 10개 응답에 공유
| GET /product/123, GET /product/456, GET /product/789 3개의 서로 다른 요청 → 한 번에 처리 (IN 절 등) → 결과 3개 → 각 요청에 개별 전달
|===

요약하면
Request Collapsing: 같은 요청 여러 개면 하나만 처리하자
Request Batching: 다른 요청이라도, 같이 묶어 처리하면 더 빠르다








