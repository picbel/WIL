// Metadata:
:description: Week I Learnt
:keywords: study, til, lwil
// Settings:
:doctype: book
:toc: left
:toclevels: 4
:sectlinks:
:icons: font
:hardbreaks:


[[section-202505]]
== 2025년 5월

[[section-202505-1일]]
1일
===
### 헤이즐캐스트 (Hazelcast)

헤이즐캐스트는 **분산 인메모리 데이터 그리드(IMDG)**로, 분산 환경에서 고속의 데이터 저장 및 처리를 지원하는 플랫폼이다. 

- 각 노드는 메모리에 데이터를 저장하며, 데이터는 파티셔닝(분할)되어 클러스터 전체에 분산된다.
- 노드 간 통신은 TCP 기반으로 이뤄지며, 특정 키에 대한 데이터는 해시 기반으로 정해진 노드에 저장된다. 
- 각 파티션은 하나 이상의 백업 노드를 가질 수 있어, 장애 발생 시 자동 페일오버가 가능하도록 설계되어 있다.

Hazelcast는 캐시로도 사용 가능하며, Map, Queue, Topic, Lock, ExecutorService 등 다양한 분산 자료구조와 연산 기능을 제공합니다.

---

[[section-202505-3일]]
3일
===
### 하이브리드 암호화란?
하이브리드 암호화는 대칭키 암호화와 비대칭키 암호화의 장점을 조합한 방식이다.

|===
| 암호 방식 | 특징 | 장점 | 단점
| **대칭키 암호화** | 같은 키로 암호화/복호화 | 빠름, 효율적 | 키 전달이 어려움
| **비대칭키 암호화** | 공개키로 암호화, 개인키로 복호화 | 키 공유 쉬움 | 느리고 계산 비용 큼
|===

**하이브리드 암호화는 대칭키로 실제 데이터를 암호화하고, 대칭키 자체는 수신자의 공개키로 암호화하여 전송한다.**

동작 예시 - 클라이언트 → 서버로 보안을 유지하면서 데이터를 보낼 때:
하이브리드 암호화 순서

1. 클라이언트가 랜덤한 대칭키(예: AES 키) 생성
2. 전송할 데이터를 AES 대칭키로 암호화
3. AES 대칭키를 서버의 공개키(RSA 등)로 암호화
4. 암호화된 데이터 + 암호화된 AES키를 함께 전송
5. 서버는 개인키로 AES키 복호화, 이 AES키로 실제 데이터를 복호화

대표 사용 예시 - HTTPS
HTTPS도 하이브리드 암호화의 대표적인 예
초기 TLS Handshake에서 대칭키(세션키)를 협상하고, 이후 데이터 통신은 빠른 대칭키 방식으로 진행한다.

---

[[section-202505-5일]]
5일
===
### 순차(Sequential) I/O, 랜덤(Random) I/O

HDD를 기준으로 설명함

#### 랜덤(Random) I/O
**데이터를 임의의 순서로 접근(읽기/쓰기)하는 방식**
HDD에서는 데이터가 물리적으로 서로 떨어진 위치에 존재하므로, 디스크 헤드가 매번 해당 위치로 이동해야 한다.

예를 들어, 100개의 데이터를 랜덤하게 읽는다면 디스크 헤드는 최대 100번 이동해야 하며, 이에 따라 **탐색 시간(Seek Time)**과 **회전 지연(Rotational Latency)**이 누적되어 전체 처리 속도가 매우 느려진다.
또한, 각 데이터 접근마다 시스템 콜이 발생하여 커널 전환 비용도 증가한다.

#### 순차(Sequential) I/O
**데이터를 연속적으로(논리적, 물리적으로) 접근하는 방식**
일반적으로 파일을 처음부터 끝까지 순서대로 읽거나 쓰는 작업이 이에 해당한다.

순차 접근은 디스크 헤드가 한 번만 위치를 맞춘 후, 그 다음 데이터들을 연속적으로 처리할 수 있어 매우 효율적이다.
논리 주소가 연속되어 있으면, 매핑 테이블을 한 번만 조회한 뒤 물리적 주소를 연속적으로 따라갈 수 있으므로, I/O 요청 횟수 및 매핑 비용이 크게 줄어든다.
예를 들어, 100개의 데이터를 순차적으로 읽는 경우, 1번의 시스템 콜과 1번의 디스크 탐색만으로 모두 처리 가능하다.

추가 설명

- SSD에서는 디스크 헤드가 없기 때문에 랜덤 I/O와 순차 I/O의 성능 차이가 줄어든다. 하지만 여전히 순차 I/O가 더 빠르며, 시스템 캐시나 내부 병렬 처리 구조에서 유리하게 작용함.
- DB에서의 클러스터링 인덱스는 순차 I/O를 유도하여 범위 쿼리 성능을 최적화한다.
- Kafka의 로그 구조도 순차 쓰기를 통해 디스크 I/O 성능을 극대화하며, 대용량 데이터 처리에 유리한 구조이다.

[cols="1,1,1", options="header"]
|===
| 항목
| 랜덤 I/O
| 순차 I/O

| 디스크 헤드 이동
| 매 접근마다 이동 → 느림
| 처음 한 번만 이동 → 빠름

| 시스템 콜 횟수
| 데이터 수만큼 발생
| 1회 혹은 최소 횟수

| 성능
| 느림 (I/O 병목 원인)
| 빠름 (고속 처리 가능)

| 논리-물리 주소 매핑
| 매번 매핑 필요
| 최초 1회 매핑 후 연속 처리 가능

| 사용 예
| Secondary Index Scan, OLTP 트랜잭션 처리
| Clustering Index, Kafka 로그 저장, 파일 일괄 처리
|===


---

[[section-202505-8일]]
8일
===
쓰레드 vs supplyAsync 사용법

