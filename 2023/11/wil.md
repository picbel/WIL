11월 3주차
===

[16일]
- 최근 스프링 공식문서를 번역해보면서 공부중인데 사소한 디테일까지 알게되는것 같아 생각보다 재미있다. \
  오늘 요약할것은 `Spring IoC 컨테이너 및 빈 소개` 글인데 내용을 간단히 요약하면 다음과 같다.
> DI는 객체가 스스로 종속성을 관리하는 대신 생성자 인수, 팩토리 메서드 인수 등 속성 설정을 통해 종속성을 정의하고, 컨테이너가 bean을 생성할 때 이러한 종속성을 주입하는 프로세스입니다. 이것은 bean이 종속성을 직접 생성하거나 Service Locator 패턴과 같은 메커니즘을 사용하여 관리하는것과 정반대의 원칙입니다.

```
용어 정리
IOC (Inversion of Control):
IOC는 제어의 역전을 의미하며, 소프트웨어 컴포넌트 간의 제어 흐름의 역전을 말합니다. 객체 스스로가 제어의 주체가 되는 것이 아니라 외부 컨테이너나 프레임워크에 의해 제어의 주체가 바뀌는 것을 의미합니다. 

DI (Dependency Injection):
DI는 의존성 주입을 나타내며, 한 객체가 다른 객체에 필요한 의존성을 주입받는 것을 의미합니다. 즉, 객체가 직접 필요한 다른 객체를 생성하지 않고 외부에서 의존성을 주입받는 것입니다. 이를 통해 객체 간의 결합도를 낮출 수 있고, 테스트하기 쉬운 코드를 작성할 수 있습니다.
```
- ApplicationContext는 BeanFactory의 하위 인터페이스이다. 다음 기능이 추가되었다 보면됩니다
  - Easier integration with Spring’s AOP features(스프링 Aop와 더 쉬운 통합)
  - Message resource handling (for use in internationalization)(메시지 리소스 처리)
  - Event publication (이벤트 개시)
  - Application-layer specific contexts such as the WebApplicationContext for use in web applications. (웹 응용 프로그램에서 사용하는 `WebApplicationContext`와 같은 응용 프로그램 레이어별 특정 컨텍스트.)

11월 4주차
===
[22일]
- 의존성 주입 관련 공식문서를 번역하였는데 해당 문서를 읽으며 기억할만한 부분을 간단히 메모하여보겠습니다.
  스프링 Dependency Injection 문서에서 DI를 설명하는것을 요약하면 다음과 같습니다.
  > Dependency Injection은 객체가 자신과 작업하는 다른객체(협업하는 객체)를 생성자, 팩토리 메서드 인수, 객체 인스턴스가 생성된 후에 설정된 속성(정보)를 통해 정의하는 프로세스입니다. 그런다음 컨테이너가 Bean을 생성할 때 이러한 의존성을 주입합니다.
  스프링에선 DI를 하면 장점을 코드가 더 깔끔하고, 결합도를 효과적으로 낮출 수 있고 테스트하기도 더 쉬워진다고 합니다.

- DI의 2가지 방법
크게 2가지 방법이 있는데 `생성자 기반 의존성 주입(Constructor-based dependency injection)` 과 `세터 기반 의존성 주입(Setter-based dependency injection)` 가 있습니다.

스프링은 2가지 방법중 권장하는 방법은 `생성자 기반 의존성 주입(Constructor-based dependency injection)` 입니다.
다음과 같은 이유로 생성자 기반 의존성 주입을 권장합니다.
1. 애플리케이션 구성요소를 변경할 수 없는 불변객체로 구현하고 필수 의존성이 null이 아님을 보장할 수 있습니다.
2. 생성자 주입된 구성 요소는 완전히 초기화된 상태입니다.
3. 생성자 인수가 너무 많은 것은 좋지않은 코드의 징후이다. 미리 확인 할 수 있다.

`세터 기반 의존성 주입(Setter-based dependency injection)` 을 사용하는 경우도 있는데 아래와 같습니다.
1. 클래스내에서 합리적인 기본값을 할당할 수 있는 선택적 의존성에 사용하여야한다. (그래야 사용시 null체크를 하지 않아도 됨)
2. 필수불가결하게 순환 의존성(Circular dependencies)을 만들어야 하는경우 (권장하는 방법은 아님)
```
순환 의존성(Circular dependencies)
classA가 classB를 참조하고 classB가 classA참조하는 이런 순환형 구조
```
- 컨테이너는 다음과 같은 방식으로 Bean의존성을 해결합니다.
> 1. `ApplicationContext` 는 모든 bean을 설명하는 구성 메타데이터로 생성되고 초기화됩니다. 구성 메타데이터는 XML, Java 코드 또는 주석을 통해 지정할 수 있습니다.
> 2. 각 bean에 대해 해당 bean의 의존성이 속성, 생성자 인수 또는 정상적인 생성자 대신 사용할 경우 정적 팩토리 메서드의 인수 형식으로 표현됩니다. 이러한 의존성은 bean이 실제로 생성될 때 제공됩니다.
> 3. 각 속성 또는 생성자 인수는 설정할 값의 실제 정의 또는 컨테이너 내의 다른 bean에 대한 참조입니다.
> 4. 값으로 표시되는 각 속성 또는 생성자 인수는 지정된 형식에서 해당 속성 또는 생성자 인수의 실제 유형으로 변환됩니다. 기본적으로 Spring은 문자열 형식으로 제공된 값을 int, long, String, boolean 등의 모든 내장된 유형으로 변환할 수 있습니다.

스프링 컨테이너는 컨테이너가 생성될 때 각 bean의 구성을 검증합니다.
그러나 bean 속성은 실제로 bean이 생성될 때까지 설정되지 않습니다.
싱글톤 범위(singleton-scoped) 및 미리 인스턴스화(pre-instantiated)로 설정된 bean은 컨테이너가 생성될 때 만들어집니다(기본값).
범위(scope)는 bean 스코프에서 정의됩니다. 그렇지 않으면 bean은 요청될 때만 생성됩니다.
bean의 생성은 bean의 의존성 및 의존성의 의존성(및 그 이후)이 생성되고 할당되면서 일련의 bean 그래프를 만들 수 있습니다. 이러한 의존성 중 해결 불일치가 발생할 수 있으며, 이는 해당 bean이 처음으로 생성될 때 나타날 수 있습니다.

일반적으로 Spring은 올바른 동작을 수행하도록 신뢰할 수 있습니다. Spring은 컨테이너 로드 시에 bean이 존재하지 않는다거나 순환 의존성과 같은 구성 문제를 감지합니다.
Spring은 속성을 설정하고 의존성을 해결하는 시기를 가능한 늦게 설정하며, 실제로 bean이 생성될 때 이러한 작업을 수행합니다. 이것은 올바르게 로드된 Spring 컨테이너가 있더라도 해당 객체를 요청할 때 문제가 발생할 경우에 대비한 것입니다. 예를 들어, bean이 bean 속성이 누락되거나 잘못된 경우에 예외를 throw할 수 있습니다. 일부 구성 문제의 이러한 지연된 가시성은 ApplicationContext 구현이 기본적으로 싱글톤 bean을 미리 인스턴스화(pre-instantiate)하는 이유입니다. 실제로 필요하기 전에 이러한 bean을 생성하는 데 약간의 초기 시간과 메모리 비용이 들지만, `ApplicationContext`가 생성될 때 구성 문제를 발견하고 나중에 발생하지 않게됩니다. 여전히 이 기본 동작을 재정의하여 싱글톤 bean이 게으르게 초기화되도록 설정할 수 있습니다.

순환 의존성이 없는 경우, 하나 이상의 협력 bean이 종속 bean에 주입될 때 각 협력 bean은 종속 bean에 주입되기 전에 완전히 구성됩니다. 이것은 bean A가 bean B에 종속성을 가지는 경우, Spring IoC 컨테이너가 bean B를 먼저 완전히 구성한 다음 bean A의 세터 메서드를 호출하기 전에 구성한다는 것을 의미합니다. 다시 말해 bean은 (미리 인스턴트화되지 않은 경우) 인스턴스화되고, 해당 의존성이 설정되며, 관련된 라이프사이클 메서드(구성된 초기화 메서드 또는 InitializingBean 콜백 메서드 등)가 호출됩니다.


- Bean을 등록하기위해서는 xml로 미리 정보를 설정하거나 @Component, @Controller 어노테이션을 이용한 컴포넌트 클래스 또는 Java기반 @Configuration을 이용한다. 이 정보들은 내부적으로 `BeanDefinition` 의 인스턴스로 변환되며 전체 Spring IoC 컨테이너 인스턴스를 로드하는 데 사용됩니다.



