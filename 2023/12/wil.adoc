4일
===

하이버네이트 6부터 DISTINCT를 더 이상 사용하지 않아도 된다고 한다. +
왜냐하면 반환되는 항목의 중복 항목은 이제 하이버네이트에 의해 필터링 되기 때문입니다. +
`QueryHints#HINT_PASS_DISTINCT_THROUGH` 또한 이제 사용하지 않다도 됩니다 +
출처: https://docs.jboss.org/hibernate/orm/6.0/migration-guide/migration-guide.html#query-sqm-distinct

---

7일
===

오늘은 스프링의 Bean Scopes 관련 정리이다.
스프링에선 크게 6개의 범위(scope)가 있고 이중 4개는 web 관련 ApplicationContext를 사용 할 때만 사용 할 수 있다.
추가로 범위를 사용자가 직접 정의하는 custom scope도 있다.
기본적인 범위 2개는 아래와 같다.
- Singleton : 기본값이며 Spring IoC 컨테이너마다 하나의 빈 정의를 하나의 객체 인스턴스로 다루는 범위입니다. 스프링에서 Bean 속성의 기본값입니다.
- Prototype : 하나의 빈 정의를 여러 개의 객체 인스턴스에서 사용하는 것(요청이 올때마다 생성하여 사용합니다)

#### Singleton Scope
싱글톤 빈은 하나의 공유된 인스턴스만 관리됩니다. 스프링 IoC 컨테이너가 해당 빈 정의에 정의된 객체를 딱 하나만 생성합니다.
해당개념은 GOF 패턴책에 정의된 싱글톤 패턴과 다릅니다. 

#### Prototype Scope
특정 빈에 대한 요청이 있을때 마다 새로운 인스턴스를 생성합니다.
다른 범위와 대조적으로 스프링은 프로토타입 빈의 전체 라이프사이클을 관리하지 않습니다.
스프링은 프로토타입 객체를 인스턴스화하고 구성후에는 추가적인 기록을 하지않습니다.
따라서 초기화 라이프 사이드 콜백 메서드(@PostConstruct)는 범위와 상관없이 호출되지만 소멸 라이프사이클 콜백(@PreDestroy)는 호출되지 않습니다.
프로토 타입의 빈의 경우 객체를 정리시에 빈이 보유한 비용이 많이 드는 리소스 해제에 대한 책임을 져야합니다.
만약 자바의 new를 대체로 프로토타입을 사용한다면 이 지점 이후 모든 라이프사이클 관리는 사용측이 처리해야합니다.


